---
title: Prompt Engineering
---

## Rating Scale Description (Описание Шкал Оценки)

### Rating (Usefulness/Efficiency) (Рейтинг (полезность/эффективность)):

Оценивает общую полезность и потенциальную эффективность метода для достижения качественных результатов при взаимодействии с LLM.

**Шкала от 1 до 100:**

**90-100 (Очень Высокий):** Фундаментальные, широко применимые и очень эффективные методы.

**75-89 (Высокий):** Очень полезные методы, значительно улучшающие результаты в большинстве релевантных сценариев.

**60-74 (Средний):** Полезные методы, дающие заметное улучшение в определенных ситуациях, но могут требовать специфических условий или иметь ограничения.

**40-59 (Низкий):** Методы с ограниченной или узкоспециализированной полезностью, или требующие значительных усилий для получения скромных результатов.

**<40 (Очень Низкий):** Методы, которые редко применимы или их эффективность сомнительна для большинства пользователей.

### Adaptability (for a regular user/standard chat) (Адаптивность (для обычного пользователя/стандартного чата)):

Оценивает, насколько легко обычный пользователь может адаптировать и применить принципы метода в стандартном чат-интерфейсе с LLM, без необходимости специального дообучения модели, доступа к API (если это не является основной частью метода для всех) или глубоких технических знаний.

**Шкала от 1 до 100:**

**90-100 (Очень Высокая):** Принципы легко понимаются и немедленно применяются в обычных промптах.

**75-89 (Высокая):** Основные концепции легко адаптируются, хотя полная реализация может быть сложнее. Требует небольшого осмысления для адаптации.

**60-74 (Средняя):** Некоторые концепции можно адаптировать, но могут требоваться более сложные промпты или понимание ограничений. Полная эффективность без API/дообучения может быть снижена.

**40-59 (Низкая):** Адаптация сложна для обычного пользователя, метод сильно зависит от API, дообучения или специфических инструментов.

**<40 (Очень Низкая):** Практически не адаптируем для стандартного чата без значительных упрощений, теряющих суть метода.

## Fundamental Techniques and Principles of Prompt Engineering (Фундаментальные Техники и Принципы Промпт-Инжиниринга)

Этот раздел освещает фундаментальные техники и принципы промпт-инжиниринга. Акцент сделан на их сути, эффективности и адаптации для задач программирования и анализа данных.

### Context Setting / Framing (Установка Контекста / Фрейминга)

- **Источник:** ["Формирование игры: как контекст влияет на принятие решений ИИ"](https://arxiv.org/pdf/2503.04840)
- **Рейтинг:** 90
- **Адаптивность:** 95

**Суть метода:**
Исследование четко показывает, что поведение LLM значительно зависит от контекста, в котором представлена задача (тема, отношения между участниками, тип "мира" — реальный/воображаемый), даже если базовая структура задачи остается неизменной. Это фундаментальный принцип: **явное и продуманное задание контекста критически важно.**

**Эффективность и Преимущества:**

- Повышает предсказуемость и согласованность ответов LLM.
- Позволяет "настроить" модель на желаемый стиль или тип ответа.
- Уменьшает вероятность нерелевантных или неуместных ответов.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Всегда начинайте промпт с четкого определения роли LLM, контекста задачи и ожидаемого стиля вывода.

**Пример Промпта (JavaScript - генерация кода в определенном контексте):**

```markdown
Контекст: Ты - опытный backend-разработчик на Node.js, пишущий высокопроизводительный
и безопасный код для финансового приложения.
Требования: Ответ должен быть только в виде кода JavaScript, без лишних пояснений.

Задача: Напиши JavaScript функцию `calculateTransactionFee(amount, type)`,
которая рассчитывает комиссию за транзакцию. Для типа "international" комиссия 2%,
для "domestic" - 0.5%. Минимальная комиссия для любого типа - $1.
```

Влияние на JavaScript/Анализ данных: Если вы просите LLM генерировать код для определенного фреймворка (React, Angular, Vue) или для специфической задачи анализа данных (например, "Ты — дата-сайентист, анализирующий временные ряды для выявления аномалий"), это сильно влияет на выбор библиотек, подходов и стиля кода.

### Formulating Requests with Answer Options / Output Space Restriction (Формулирование Запросов с Вариантами Ответов / Ограничение Выходного Пространства)

- **Источник:** ["Обратите внимание на разрыв уверенности"](https://arxiv.org/pdf/2409.12214) (особенно "Предоставление вариантов ответов")
- **Рейтинг:** 80
- **Адаптивность:** 85

**Суть метода:**
Исследование показывает, что предоставление LLM вариантов ответа (как в задачах с множественным выбором) или явное ограничение пространства возможных ответов может значительно повысить точность, особенно для менее крупных моделей, и улучшить калибровку их уверенности.

**Эффективность и Преимущества:**

- Повышает точность ответов, направляя модель.
- Снижает вероятность генерации совершенно неверных или "галлюцинаторных" ответов.
- Улучшает калибровку уверенности модели.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Когда вам нужен конкретный ответ из ограниченного набора, или когда вы хотите проверить понимание моделью чего-либо.

**Пример Промпта (JavaScript - выбор подходящего метода массива):**

```markdown
Задача: Какой метод массива JavaScript наиболее подходит для создания нового
массива, содержащего квадраты всех чисел из исходного массива?

Варианты ответов:
A) forEach()
B) map()
C) filter()
D) reduce()

Выбери один вариант и кратко объясни, почему он наиболее подходит.
```

### Principle Technique / Explicit Guiding Statements (Техника "Принципов" / Явное Задание Руководящих Утверждений)

- **Источник:** ["Оценка управляемости подсказок больших языковых моделей"](https://arxiv.org/pdf/2411.12405) (особенно "Техника 'Принципов'")
- **Рейтинг:** 85
- **Адаптивность:** 90

**Суть метода:**
Включение в начало промпта набора "принципов", "убеждений" или "руководящих утверждений", которым модель должна следовать при генерации ответа. Это позволяет "настроить" или "направить" поведение модели в соответствии с желаемой персоной или этической рамкой.

**Эффективность и Преимущества:**

- Повышает управляемость (steerability) модели.
- Позволяет получать более персонализированные, последовательные и предсказуемые ответы.
- Полезно для создания контента в определенном стиле или с определенной точкой зрения.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Задание стиля кодирования, принципов проектирования или этических рамок при генерации кода или аналитических выводов.

**Пример Промпта (JavaScript - генерация кода с принципами SOLID):**

```markdown
Ты - опытный JavaScript-разработчик, придерживающийся принципов SOLID.
Принципы, которым ты следуешь:

1. Принцип единственной ответственности (Single Responsibility Principle).
2. Принцип открытости/закрытости (Open/Closed Principle).
3. (и так далее, если нужно)

Задача: Разработай структуру классов на JavaScript для системы управления
заказами в интернет-магазине (например, классы Order, Product, Customer).
Убедись, что твоя реализация соответствует указанным выше принципам.
Кратко поясни, как каждый класс соответствует этим принципам.
```

### Multi-Sampling and Aggregation of Results (Мульти-сэмплинг и Агрегация Результатов)

- **Источник:** ["Генерация ключевых фраз без обучения"](https://arxiv.org/pdf/2503.00597) (стратегии агрегации) и принцип Self-Consistency
- **Рейтинг:** 82
- **Адаптивность:** 80 (требует нескольких запросов или настроек температуры)

**Суть метода:**
Генерация нескольких ответов на один и тот же промпт (возможно, с небольшими вариациями или повышенной "температурой" модели для большего разнообразия) и последующая их агрегация. Агрегация может быть выбором самого частого ответа (как в Self-Consistency), объединением, выбором лучшего по каким-то критериям.

**Эффективность и Преимущества:**

- Повышает надежность и точность ответов, особенно для задач, где есть несколько корректных решений или где модель может дать случайную ошибку.
- Снижает влияние случайных флуктуаций в генерации.
- Помогает выявить наиболее вероятный или консенсусный ответ.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Генерация вариантов рефакторинга JS кода: Попросить 3-5 вариантов рефакторинга функции и затем выбрать лучший.

**Пример Промпта (JavaScript - генерация нескольких вариантов функции):**

```markdown
Задача: Напиши JavaScript функцию для преобразования строки в kebab-case
(например, "helloWorld" -> "hello-world").

Сгенерируй 3 РАЗНЫХ, но корректных варианта реализации этой функции.
Для каждого варианта кратко опиши его подход.

(После получения ответов, пользователь может сам выбрать лучший или попросить LLM выбрать на основе критериев)
```

### Ensembling and Model Uncertainty Awareness (Ансамблирование и Учет Неопределенности Модели)

- **Источник:** ["Осведомленное объединение с учетом неопределенности (UAF)"](https://arxiv.org/pdf/2503.05757)
- **Рейтинг:** 78 (концептуально)
- **Адаптивность:** 75 (принципы адаптируемы, полная реализация сложна)

**Суть метода:**
Комбинирование ответов от нескольких разных LLM (или одной LLM с разными настройками/промптами) с учетом их предполагаемой точности или "уверенности" для конкретной задачи. Это может включать запрос модели оценить свою уверенность в ответе.

**Эффективность и Преимущества:**

- Снижает вероятность принятия неверной информации.
- Повышает фактическую точность, особенно для критически важных запросов.
- Дает лучшее понимание ограничений моделей и уровня доверия к их ответам.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Если у вас есть доступ к нескольким моделям, можно задать один и тот же вопрос (например, по сложной проблеме в JavaScript или интерпретации данных) нескольким моделям. Затем сравнить ответы. Можно также попросить одну модель оценить уверенность в своем ответе.

**Пример Промпта (имитация запроса на оценку уверенности):**

```markdown
Задача: Объясни разницу между `null` и `undefined` в JavaScript.

Пожалуйста, дай свой ответ и оцени свою уверенность в его полноте и точности
по шкале от 1 до 10 (где 10 - абсолютная уверенность).
Если твоя уверенность ниже 8, укажи, какие аспекты могут требовать дополнительного уточнения.
```

### Explicit Permission for Exceptions / Balance Between Rules and Flexibility (Явное Разрешение на Исключения / Баланс между Правилами и Гибкостью)

- **Источник:** ["Обучение ИИ обработке исключений"](https://arxiv.org/pdf/2503.02976)
- **Рейтинг:** 75
- **Адаптивность:** 85

**Суть метода:**
LLM часто слишком строго следуют правилам. Промпт должен явно указывать на возможность и разумность исключений из правил, если ситуация того требует, и запрашивать у модели объяснение такого решения.

**Эффективность и Преимущества:**

- Позволяет получать более гибкие и человекоподобные ответы в ситуациях, требующих нюансов.
- Избегает непрактичных или контрпродуктивных решений из-за слепого следования правилам.

**Практическое Применение и Адаптация для JS/Анализа данных:**
При запросе на применение каких-либо правил (стандарты кодирования, бизнес-логика, правила анализа данных), можно добавить указание на возможность обоснованных отступлений.

**Пример Промпта (JavaScript - применение eslint правил с возможными исключениями):**

```markdown
Задача: Проверь следующий фрагмент JavaScript кода на соответствие
правилам eslint-config-airbnb.

Код:
// ... фрагмент кода ...

ВАЖНО: Хотя ты должен стремиться к полному соответствию правилам, помни,
что в некоторых специфических ситуациях могут быть разумные исключения,
если строгое следование правилу ухудшает читаемость или производительность
без значимой пользы.
Если ты предлагаешь отступление от правила, ЧЕТКО ОБЪЯСНИ, почему это
оправдано в данном конкретном случае.

Укажи все несоответствия и предложи исправления или обоснованные исключения.
```

### Prompt Style Choice: Memorization vs. Generalization Focus (Выбор Стиля Промпта: Акцент на Меморизацию vs. Генерализацию)

- **Источник:** ["Обобщение против запоминания"](https://arxiv.org/pdf/2407.14985)
- **Рейтинг:** 70
- **Адаптивность:** 80

**Суть метода:**
Сознательный выбор формулировок промпта в зависимости от того, нужен ли точный ответ, основанный на запомненных данных (меморизация), или новое, обобщенное или креативное решение (генерализация).

**Эффективность и Преимущества:**

- Повышает точность фактических ответов при использовании "меморизующих" промптов.
- Стимулирует более креативные и оригинальные решения при использовании "генерализующих" промптов.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Нужен точный синтаксис JS функции из MDN? Формулируйте запрос близко к тому, как это описано в документации.

**Пример Промпта (JavaScript - акцент на генерализацию для новой идеи):**

```markdown
Задача: Предложи НОВУЮ и НЕСТАНДАРТНУЮ метафору для объяснения
концепции асинхронного программирования в JavaScript (Promises, async/await)
человеку, не знакомому с программированием, но любящему готовить еду.

Избегай стандартных объяснений про "официанта и заказ на кухне".
Подумай о процессе приготовления сложного блюда с несколькими этапами,
которые могут выполняться параллельно или последовательно.
Цель - максимальная наглядность и оригинальность.
```

### Accounting for LLM Interpretation of Subjective Language (Учет Особенностей Интерпретации LLM Субъективного Языка)

- **Источник:** ["Выявление недостатков в том, как люди и большие языковые модели интерпретируют субъективный язык"](https://arxiv.org/pdf/2503.04113) (метод TED)
- **Рейтинг:** 70 (концептуальное понимание)
- **Адаптивность:** 80 (осознанность при формулировании)

**Суть метода:**
LLM могут неожиданно интерпретировать субъективные инструкции ("энтузиастичный" текст может стать "нечестным", "остроумный" - "оскорбительным"). Важно понимать это и при необходимости использовать более конкретные, объективные формулировки вместо субъективных, если требуется предсказуемый результат.

**Эффективность и Преимущества:**

- Более предсказуемые ответы от LLM, когда важна точность тона или содержания.
- Снижение риска получения контента с нежелательными коннотациями.

**Практическое Применение и Адаптация для JS/Анализа данных:**
При запросе на генерацию текста (например, комментариев к JS коду, описаний для отчетов по данным), если важен определенный тон, лучше задать его через конкретные атрибуты, а не субъективные прилагательные.

**Пример Промпта (JavaScript - генерация комментариев с конкретикой вместо субъективности):**

```markdown
Задача: Напиши комментарии для следующей сложной JavaScript функции.

Функция:
function complexAlgorithm(data) { /_ ... много логики ... _/ }

Вместо того чтобы просить: "Напиши ПОЛЕЗНЫЕ и ПОНЯТНЫЕ комментарии."

Сформулируй так:
"Напиши комментарии для этой JavaScript функции, которые:

1. Объясняют НАЗНАЧЕНИЕ каждого основного блока кода.
2. Указывают на ВРЕМЕННУЮ СЛОЖНОСТЬ ключевых операций.
3. Предупреждают о возможных ГРАНИЧНЫХ СЛУЧАЯХ или НЕОЧЕВИДНОМ ПОВЕДЕНИИ.
4. Используют точные технические термины.
   Избегай общих или расплывчатых фраз.
```

## Advanced Prompt Engineering Techniques (Продвинутые Техники Промпт-Инжиниринга)

Этот раздел детализирует продвинутые техники промпт-инжиниринга, с анализом их эффективности и примерами адаптации для JavaScript и анализа данных.

### Causalized Chain of Thought (CauCoT) (Причинное CauCoT)

- **Рейтинг:** 75 (потенциально выше для сложных логических задач)
- **Адаптивность:** 75 (требует внимательного структурирования промпта)

**Суть метода:**
Метод CauCoT (Causalized Chain of Thought) делает рассуждения LLM не только правильными, но и понятными, моделируя причинно-следственные связи между шагами рассуждений с помощью структурных причинных моделей (SCM). Использует ролевые запросы для исправления шагов без причинных связей.

**Эффективность и Преимущества:**

- Значительно улучшает качество ответов языковых моделей, особенно в сложных задачах, требующих логических выводов.
- Делает процесс рассуждения модели более прозрачным и интерпретируемым.
- Помогает выявлять и исправлять ошибки в логической цепочке.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Этот подход особенно ценен для отладки сложных алгоритмов, анализа зависимостей в данных или построения объяснимых моделей машинного обучения.

**Пример Промпта (JavaScript - отладка сложной логики):**

```markdown
Задача: Проанализировать и отладить JavaScript функцию,
которая неправильно рассчитывает итоговую скидку на товар.

Исходная (потенциально ошибочная) JavaScript функция:
```

```javascript
function calculateFinalPrice(basePrice, userType, promoCode) {
  let discount = 0
  if (userType === 'premium') {
    discount += 0.1 // 10% для премиум
  }
  if (promoCode === 'SUMMER20') {
    discount = 0.2 // 20% по промокоду (перезаписывает предыдущую?)
  }
  // Предположим, есть еще логика сложения скидок или выбора максимальной,
  // которая может быть неверной.
  return basePrice * (1 - discount)
}
```

```markdown
Используй причинно-следственный подход (CauCoT) для анализа:

1. Разбей логику функции на последовательные шаги вычисления скидки и итоговой цены.
2. Для каждого шага явно укажи, ПОЧЕМУ он следует из предыдущего
   (например, "Если userType === 'premium', то скидка увеличивается на 0.1,
   ПОТОМУ ЧТО это условие для премиум-скидки").
3. Проверь, что каждый шаг имеет ПРИЧИННУЮ СВЯЗЬ с предыдущим
   и с общей логикой применения скидок (например, должны ли скидки
   суммироваться или выбираться максимальная?).
4. Если заметишь отсутствие причинной связи или логический разрыв
   (например, перезапись скидки вместо сложения, если это не предполагалось),
   вернись и ИСПРАВЬ рассуждение и код.
5. В конце проверь, что вся цепочка рассуждений не содержит логических разрывов.

Объясни свое рассуждение и предложи исправленный код.
Помни: каждый шаг должен быть ПРИЧИННО ОБОСНОВАН предыдущими шагами
и условиями задачи.
```

### Structured CoT (Structure Search as part of System 2) (Структурный CoT (Structure Search как часть Системы 2))

- **Рейтинг:** 80
- **Адаптивность:** 85

**Суть метода:**
"Структурированное рассуждение (Structure Search)" – это часть перехода LLM к мышлению Системы 2. Реализуется через промпты, которые Просят модель рассматривать проблему поэтапно. Предлагают исследовать несколько путей решения. Указывают на необходимость проверки промежуточных результатов.

**Эффективность и Преимущества:**

- Улучшает качество решений для сложных, многоэтапных задач.
- Помогает избежать преждевременных выводов.
- Делает процесс решения более управляемым и прозрачным.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Идеально для проектирования архитектуры JavaScript-приложения, выбора оптимального алгоритма для анализа данных или декомпозиции сложной задачи на подзадачи.

**Пример Промпта (JavaScript - выбор структуры данных):**

```markdown
Задача: Выбрать оптимальную структуру данных в JavaScript для хранения
и быстрого поиска информации о пользователях по их ID и email.
Данные о пользователях включают: id, name, email, registrationDate.
Ожидаются частые операции поиска по ID и email, редкие добавления/удаления.

Используй структурированное рассуждение (Structure Search):

1. ПОЭТАПНЫЙ АНАЛИЗ:

   - Определи основные требования к структуре данных (быстрый поиск по двум ключам).
   - Перечисли возможные операции и их частоту.

2. ИССЛЕДОВАНИЕ АЛЬТЕРНАТИВНЫХ ПУТЕЙ РЕШЕНИЯ (минимум 2-3):

   - Рассмотри использование:
     a) Массива объектов с ручным поиском.
     b) Одного объекта/Map, где ключи - ID, а значения - объекты пользователей (как искать по email?).
     c) Двух объектов/Map: один для поиска по ID (id -> user), другой для поиска по email (email -> id или email -> user).
     d) Другие релевантные структуры (например, кастомный класс с индексами).
   - Для каждой альтернативы оцени:
     - Сложность реализации.
     - Производительность операций поиска (по ID, по email).
     - Производительность операций добавления/удаления.
     - Потребление памяти.

3. ПРОВЕРКА ПРОМЕЖУТОЧНЫХ ВЫВОДОВ:

   - Обоснуй свои оценки для каждой альтернативы.

4. ВЫБОР И ОБОСНОВАНИЕ:
   - Выбери наиболее подходящую структуру данных и подробно объясни, почему
     именно она является оптимальной для данной задачи, учитывая все критерии.
   - Приведи краткий пример ее реализации на JavaScript.
```

### Program-of-Thoughts (PoT) / Program-aided Language Models (PAL) (Программное размышление)

- **Рейтинг:** 85 (для задач, где код может помочь в рассуждении)
- **Адаптивность:** 70 (требует от LLM умения генерировать и понимать код)

**Суть метода:**
LLM не просто генерирует текстовое рассуждение, а пишет небольшую программу (например, на Python или JavaScript) для выполнения вычислений, логических операций или симуляций как часть своего мыслительного процесса. Затем результат выполнения этой программы используется для формирования окончательного ответа.

**Эффективность и Преимущества:**

- Значительно повышает точность в задачах, требующих точных вычислений, сложных логических шагов или работы с данными.
- Снижает вероятность арифметических и логических ошибок, присущих чисто текстовым рассуждениям LLM.
- Позволяет решать более сложные задачи, которые трудно или невозможно решить только вербально.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Анализ данных: LLM может написать JS-скрипт для агрегации, фильтрации или трансформации JSON-данных.
- Решение математических или алгоритмических задач: Генерация JS-кода для проверки гипотез или вычисления результатов.
- Симуляции: Создание простого JS-кода для моделирования какого-либо процесса.

**Пример Промпта (JavaScript - анализ данных о продажах):**

```markdown
Задача: Проанализировать данные о продажах и определить самый прибыльный товар.

Данные о продажах (массив JSON объектов):
```

```javascript
const salesData = [
  {productName: 'Laptop', quantity: 10, price: 1200, cost: 800},
  {productName: 'Mouse', quantity: 50, price: 25, cost: 10},
  {productName: 'Keyboard', quantity: 30, price: 75, cost: 35},
  {productName: 'Laptop', quantity: 5, price: 1200, cost: 800},
]
```

```markdown
Используй программное размышление (Program-of-Thoughts):

1. Сформулируй план:
   a. Для каждого уникального продукта рассчитать общую выручку (quantity _ price).
   b. Для каждого уникального продукта рассчитать общую себестоимость (quantity _ cost).
   c. Для каждого уникального продукта рассчитать общую прибыль (выручка - себестоимость).
   d. Найти продукт с максимальной общей прибылью.
2. Напиши JavaScript код, который реализует этот план для предоставленных `salesData`.
   Код должен агрегировать данные по `productName`.
3. (Представь, что ты выполняешь этот код) Покажи промежуточные результаты
   (например, объект с общей прибылью для каждого продукта).
4. На основе результатов выполнения кода, дай окончательный ответ: какой товар самый прибыльный
   и какова его общая прибыль.

Пожалуйста, предоставь и план, и JavaScript код, и финальный вывод.
```

**Примечание:** В этом примере LLM делегирует вычисления коду, что повышает надежность.

### Tree of Thoughts (ToT) (Дерево Мыслей)

- **Рейтинг:** 80 (для исследовательских и сложных задач)
- **Адаптивность:** 70 (сложно полностью реализовать в простом чате, но принципы применимы)

**Суть метода:**
ToT позволяет LLM исследовать различные пути рассуждений ("ветви дерева") параллельно. Модель генерирует несколько промежуточных "мыслей" или шагов для каждого этапа решения, оценивает их перспективность и выбирает наиболее обещающие для дальнейшего развития. Это имитирует человеческое исследование различных вариантов решения.

**Эффективность и Преимущества:**

- Улучшает решение сложных задач, где требуется исследование или нет очевидного пути.
- Позволяет модели "отступать" от тупиковых путей рассуждений.
- Повышает качество генерируемых планов и решений.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Проектирование сложных систем на JavaScript: Исследование различных архитектурных подходов.
- Написание тестов для сложных случаев: Генерация различных тестовых сценариев.
- Поиск оптимальных путей в графах данных: Если данные можно представить как граф.

**Пример Промпта (JavaScript - выбор JS фреймворка для проекта):**

```markdown
Задача: Выбрать наиболее подходящий JavaScript UI фреймворк (React, Vue, или Svelte)
для нового проекта: "Интерактивная образовательная платформа для детей".

Используй принципы Дерева Мыслей (Tree of Thoughts):

1. КОРНЕВАЯ МЫСЛЬ: "Выбрать лучший JS UI фреймворк для детской образовательной платформы."

2. ГЕНЕРАЦИЯ ВОЗМОЖНЫХ СЛЕДУЮЩИХ МЫСЛЕЙ/КРИТЕРИЕВ (Уровень 1):

   - Для каждого из фреймворков (React, Vue, Svelte) рассмотри следующие аспекты:
     a) Порог входа и скорость разработки (важно для быстрого прототипирования).
     b) Производительность (важно для интерактивных элементов).
     c) Экосистема и доступность библиотек (для готовых UI-компонентов, анимаций).
     d) Поддержка сообщества и документация.
     e) Особенности, важные для детских приложений (например, легкость создания анимаций, доступность).

3. ОЦЕНКА ПЕРСПЕКТИВНОСТИ И РАЗВИТИЕ ВЕТВЕЙ (Уровень 2):

   - Для каждого фреймворка и каждого аспекта из п.2 приведи краткий анализ (+/-).
     Например, для React + "Порог входа": "Может быть выше для новичков из-за JSX и концепций,
     но много готовых решений".

4. (Имитация отката, если нужно) Если какой-то фреймворк явно не подходит по
   критическому параметру, отметь это и не развивай эту ветвь дальше.

5. ФИНАЛЬНЫЙ ВЫВОД:
   - Сравни фреймворки по всем оцененным аспектам.
   - Сделай аргументированный вывод, какой фреймворк (или комбинация)
     наиболее подходит, и почему. Укажи возможные компромиссы.

Пожалуйста, структурируй свой ответ, отражая этот процесс исследования.
```

**Примечание:** Прямая реализация ToT сложна, но можно имитировать исследование альтернатив и их оценку.

### Contrastive Prompting (Контрастный Промптинг)

- **Рейтинг:** 78
- **Адаптивность:** 85

**Суть метода:**
Предоставление модели как положительных, так и отрицательных примеров, или явное указание на то, что нужно и чего не нужно делать. Это помогает модели лучше понять границы желаемого ответа.

**Эффективность и Преимущества:**

- Повышает точность и управляемость генерации.
- Снижает вероятность нежелательных выходов.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Генерация кода в определенном стиле: "Пиши код в функциональном стиле. НЕ используй циклы for, предпочитай map/filter/reduce."
- Фильтрация данных: "Отбери пользователей, которые активны. НЕ включай пользователей, которые заблокированы."

**Пример Промпта (JavaScript - генерация кода с контрастными указаниями):**

```markdown
Задача: Напиши JavaScript функцию `getUserData(userId)`, которая получает данные
пользователя с сервера.

ПОЛОЖИТЕЛЬНЫЕ ИНСТРУКЦИИ (ЧТО ДЕЛАТЬ):

- Используй `async/await` для асинхронных операций.
- Используй `fetch` для HTTP-запросов.
- Обрабатывай возможные ошибки сети и ошибки ответа сервера (например, статус 404, 500).
- В случае ошибки возвращай `null`.
- Добавь JSDoc комментарии для функции и ее параметров.

ОТРИЦАТЕЛЬНЫЕ ИНСТРУКЦИИ (ЧЕГО НЕ ДЕЛАТЬ):

- НЕ используй `XMLHttpRequest`.
- НЕ используй коллбэки в стиле `then/catch` (предпочитай `async/await` с `try/catch`).
- НЕ выводи ошибки в консоль внутри функции, просто возвращай `null`.
- НЕ добавляй никакой UI логики, функция должна быть чисто для получения данных.

Пример URL: `/api/users/${userId}`
```

### Chain of Draft (CoD) / Iterative Refinement (Цепочка Черновиков)

- **Рейтинг:** 88
- **Адаптивность:** 90

**Суть метода:**
Это итеративный процесс:

- Черновик (Draft): LLM генерирует первоначальный ответ/код.
- Оценка (Evaluate): Пользователь (или другая LLM) оценивает черновик по заданным критериям, выявляет ошибки или области для улучшения.
- Улучшение (Refine): LLM получает обратную связь и генерирует улучшенную версию.
  Цикл может повторяться.

**Эффективность и Преимущества:**

- Значительно улучшает качество сложных ответов.
- Позволяет постепенно приближаться к желаемому результату.
- Хорошо подходит для задач, где трудно сразу сформулировать идеальный промпт.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Рефакторинг JavaScript кода: Сначала получить рабочий вариант, затем итеративно улучшать читаемость, производительность.
- Создание сложных SQL-запросов или скриптов для анализа данных: Начать с простого, затем усложнять и оптимизировать.

**Пример Промпта (JavaScript - создание сложного компонента):**

```markdown
Задача: Создать JavaScript компонент "Фильтруемый список товаров" с использованием React.

ЭТАП 1: Черновик
Пожалуйста, создай базовую структуру React компонента `ProductList` который:

1. Принимает массив `products` через props.
2. Отображает каждый продукт (например, только `product.name` и `product.price`).
3. Включает простое текстовое поле для ввода фильтра по названию.

(После получения ответа от LLM, пользователь его анализирует)

ЭТАП 2: Оценка и Запрос на Улучшение
Отлично, базовый компонент работает. Теперь давай улучшим:

1. Реализуй логику фильтрации: список должен обновляться при изменении текста в поле фильтра.
   Фильтрация должна быть нечувствительна к регистру.
2. Добавь сортировку по цене (возрастание/убывание) с помощью кнопок.
3. Сделай код более модульным, возможно, вынеся `ProductItem` в отдельный компонент.
   Пожалуйста, предоставь обновленный код.
```

### Chain of Thought (CoT) (Цепочка Размышлений (Chain of Thought, CoT))

- **Рейтинг:** 90 (фундаментальный метод)
- **Адаптивность:** 95

**Суть метода:**
Побуждение LLM генерировать последовательность промежуточных шагов рассуждения перед тем, как дать окончательный ответ. Обычно активируется фразой "Давай подумаем шаг за шагом" или демонстрацией примеров с рассуждениями.

**Эффективность и Преимущества:**

- Значительно улучшает способность LLM решать задачи, требующие многошаговых рассуждений (арифметические, логические, здравый смысл).
- Делает процесс мышления модели более явным.
- Снижает количество ошибок.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Универсально применим для любых сложных задач генерации или анализа кода/данных.

**Пример Промпта (JavaScript - решение алгоритмической задачи):**

```markdown
Задача: Дана строка JavaScript кода. Определи, является ли использование
переменной `myVar` в последней строке безопасным (т.е. была ли она
объявлена и инициализирована в доступной области видимости).

Код:
```

```javascript
const codeSnippet = `
function exampleScope() {
  let x = 10;
  if (x > 5) {
    const myVar = "Hello";
    console.log(myVar);
  }
  // console.log(myVar); // Эта строка закомментирована, но представим, что мы ее анализируем
}
// Какая строка анализируется: console.log(myVar); (представим, что она раскомментирована ВНЕ функции)
`
```

```markdown
Проанализируй этот код и ответь на вопрос.
Давай подумаем шаг за шагом:

1. Где объявлена переменная `myVar`?
2. Какова область видимости этого объявления (`let`, `const` блочная область видимости)?
3. Находится ли анализируемая строка `console.log(myVar)` (ВНЕ функции)
   внутри области видимости `myVar`?
4. Сделай вывод о безопасности использования.
```

### Self-Correction, Self-Refine, Self-Critique Methods (Методы самопроверки)

- **Рейтинг:** 88
- **Адаптивность:** 90

**Суть метода:**
LLM просят не только сгенерировать ответ, но и затем оценить его, найти ошибки/недостатки и предложить исправления. Это может быть итеративным процессом.

**Эффективность и Преимущества:**

- Улучшает точность и надежность ответов.
- Помогает модели исправлять собственные ошибки.
- Особенно полезно, когда нет четких внешних критериев для проверки.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- После генерации JavaScript кода, попросить LLM:
  - "Проверь этот код на наличие распространенных ошибок."
  - "Предложи улучшения для этого кода с точки зрения читаемости и производительности."
  - "Критически оцени это решение. Какие у него есть недостатки?"

**Пример Промпта (JavaScript - самопроверка сгенерированного кода):**

```markdown
Задача: Напиши JavaScript функцию, которая удаляет дубликаты из массива чисел.

(LLM генерирует первую версию, например, с использованием вложенных циклов)
```

```javascript
function removeDuplicatesV1(arr) {
  const result = []
  for (let i = 0; i < arr.length; i++) {
    if (result.indexOf(arr[i]) === -1) {
      result.push(arr[i])
    }
  }
  return result
}
```

```markdown
Запрос на самопроверку и улучшение:
"Спасибо за эту версию `removeDuplicatesV1`.
Теперь, пожалуйста, выполни самопроверку:

1. Оцени временную сложность этой реализации.
2. Есть ли более эффективные способы решения этой задачи в JavaScript
   (например, с использованием Set или других подходов)?
3. Предложи улучшенную версию функции (`removeDuplicatesV2`)
   с лучшей производительностью и объясни свои изменения."
```

### Chain-of-Verification (CoV) (Цепочка Верификаций)

- **Рейтинг:** 85
  **Адаптивность:** 80 (требует внимательного формулирования проверочных вопросов)

**Суть метода:**
Модель сначала генерирует базовый ответ. Затем она генерирует набор верификационных вопросов, чтобы проверить факты в своем ответе. Наконец, она отвечает на эти вопросы (возможно, с поиском информации) и генерирует финальный, улучшенный ответ на основе верификации.

**Эффективность и Преимущества:**

- Значительно снижает галлюцинации и фактические ошибки.
- Улучшает точность ответов, особенно для фактологических запросов.
- Делает процесс проверки более явным.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Проверка документации для JavaScript библиотеки: Сгенерировать описание, затем верификационные вопросы к этому описанию, затем улучшить описание.
- Анализ данных с выводами: Сделать первоначальный вывод, затем сформулировать вопросы для проверки этого вывода по данным, затем уточнить вывод.

**Пример Промпта (JavaScript - объяснение концепции с CoV):**

```markdown
Задача: Объясни концепцию "замыканий" (closures) в JavaScript для начинающего.

Используй метод Цепочки Верификаций (Chain-of-Verification):

1. ПЕРВОНАЧАЛЬНЫЙ ОТВЕТ:

   - Сначала дай базовое объяснение замыканий в JavaScript.

2. ГЕНЕРАЦИЯ ВЕРИФИКАЦИОННЫХ ВОПРОСОВ:

   - Затем, составь 3-4 вопроса, чтобы проверить ключевые аспекты твоего
     объяснения. Например:
     - "Сохраняет ли замыкание доступ к переменным внешней функции после
       ее завершения?"
     - "Приведет ли мой пример кода к созданию замыкания?"
     - "Какие практические применения у замыканий?"

3. ОТВЕТЫ НА ВЕРИФИКАЦИОННЫЕ ВОПРОСЫ:

   - Ответь на каждый из этих вопросов, уточняя и проверяя свое первоначальное объяснение.

4. ФИНАЛЬНЫЙ УЛУЧШЕННЫЙ ОТВЕТ:
   - На основе проведенной верификации, предоставь окончательное,
     более точное и полное объяснение замыканий в JavaScript,
     включая простой пример кода.
```

### Word / Block Order in Prompts (Порядок слов/блоков в промптах)

- **Рейтинг:** 70-80 (зависит от модели и сложности задачи)
- **Адаптивность:** 90

**Суть метода:**

- **(Контроль разнообразия):** Порядок блоков в промпте (базовая информация, память, предыдущие диалоги, окружение, текущий диалог) и частота имен существенно влияют на разнообразие диалогов. Хронологический порядок информации часто лучше.
- **(HPSS для LLM-оценщиков):** Порядок компонентов в промпте для оценки (шкала, примеры, критерии, CoT и т.д.) влияет на качество оценки. Рекомендуется размещать описание задачи в начале для логической структуры.

**Эффективность и Преимущества:**

- Может влиять на фокус модели, последовательность рассуждений и качество вывода.
- Правильный порядок может улучшить понимание моделью контекста и задачи.

**Практическое Применение и Адаптация для JS/Анализа данных:**

Общее правило: Наиболее важные инструкции или контекст часто лучше размещать в начале или в конце промпта (в зависимости от модели и того, на что она "обращает больше внимания" - начало или конец).

Для генерации кода: Сначала контекст и ограничения, затем конкретная задача.

```markdown
Контекст: Я работаю над Node.js приложением, использую Express.js.
Ограничение: Используй только асинхронные функции с async/await.
Задача: Напиши middleware для логирования всех входящих запросов (метод, URL, время).
```

Для анализа данных: Сначала данные, затем инструкции по анализу.

```markdown
Данные:
const data = [...];
Задача: Проанализируй эти данные и найди среднее значение поля 'value'.
```

Для сложных промптов с несколькими инструкциями: Структурируйте промпт логически:

- Описание задачи/цели.
- Критерии/ограничения.
- Примеры (если есть).
- Формат вывода.
- Конкретные инструкции/шаги.

**Примечание:** Эффект порядка слов/блоков может быть не всегда очевиден и требует экспериментов. Однако, следование логической структуре обычно полезно.
