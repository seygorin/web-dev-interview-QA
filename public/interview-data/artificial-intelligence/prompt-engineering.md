---
title: Prompt Engineering
---

## Rating Scale Description (Описание Шкал Оценки)

### Rating (Usefulness / Efficiency) (Рейтинг (полезность / эффективность)):

Оценивает общую полезность и потенциальную эффективность метода для достижения качественных результатов при взаимодействии с LLM.

**Шкала от 1 до 100:**

**90-100 (Очень Высокий):** Фундаментальные, широко применимые и очень эффективные методы.

**75-89 (Высокий):** Очень полезные методы, значительно улучшающие результаты в большинстве релевантных сценариев.

**60-74 (Средний):** Полезные методы, дающие заметное улучшение в определенных ситуациях, но могут требовать специфических условий или иметь ограничения.

**40-59 (Низкий):** Методы с ограниченной или узкоспециализированной полезностью, или требующие значительных усилий для получения скромных результатов.

**<40 (Очень Низкий):** Методы, которые редко применимы или их эффективность сомнительна для большинства пользователей.

### Adaptability (for a regular user / standard chat) (Адаптивность (для обычного пользователя / стандартного чата)):

Оценивает, насколько легко обычный пользователь может адаптировать и применить принципы метода в стандартном чат-интерфейсе с LLM, без необходимости специального дообучения модели, доступа к API (если это не является основной частью метода для всех) или глубоких технических знаний.

**Шкала от 1 до 100:**

**90-100 (Очень Высокая):** Принципы легко понимаются и немедленно применяются в обычных промптах.

**75-89 (Высокая):** Основные концепции легко адаптируются, хотя полная реализация может быть сложнее. Требует небольшого осмысления для адаптации.

**60-74 (Средняя):** Некоторые концепции можно адаптировать, но могут требоваться более сложные промпты или понимание ограничений. Полная эффективность без API/дообучения может быть снижена.

**40-59 (Низкая):** Адаптация сложна для обычного пользователя, метод сильно зависит от API, дообучения или специфических инструментов.

**<40 (Очень Низкая):** Практически не адаптируем для стандартного чата без значительных упрощений, теряющих суть метода.

## Fundamental Techniques and Principles of Prompt Engineering (Фундаментальные Техники и Принципы Промпт-Инжиниринга)

Этот раздел освещает фундаментальные техники и принципы промпт-инжиниринга. Акцент сделан на их сути, эффективности и адаптации для задач программирования и анализа данных.

### Context Setting / Framing (Установка Контекста / Фрейминга)

- **Источник:** ["Формирование игры: как контекст влияет на принятие решений ИИ"](https://arxiv.org/pdf/2503.04840)
- **Рейтинг:** 90
- **Адаптивность:** 95

**Суть метода:**
Исследование четко показывает, что поведение LLM значительно зависит от контекста, в котором представлена задача (тема, отношения между участниками, тип "мира" — реальный/воображаемый), даже если базовая структура задачи остается неизменной. Это фундаментальный принцип: **явное и продуманное задание контекста критически важно.** Установка контекста — это не просто определение роли для LLM (например, "Ты программист"), но и создание определенной "рамки" или "сценария", который направляет мышление модели. Модель пытается соответствовать предоставленному фрейму, что влияет на её выбор лексики, стиля, глубины анализа и даже на принимаемые "решения" в игровых или симуляционных сценариях.

**Эффективность и Преимущества:**

- **Повышает предсказуемость и согласованность ответов LLM:** Когда модель понимает "правила игры" или ожидаемый сценарий, её ответы становятся более релевантными и менее случайными.
- **Позволяет "настроить" модель на желаемый стиль или тип ответа:** Например, запрос на код в контексте "академического исследования" может дать более формальный и документированный код, чем в контексте "быстрого прототипирования стартапа".
- **Уменьшает вероятность нерелевантных или неуместных ответов:** Четкий контекст сужает пространство возможных интерпретаций запроса.
- **Улучшает специфичность:** Помогает модели генерировать ответы, более точно соответствующие узкой предметной области или конкретным требованиям задачи.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Всегда начинайте промпт с четкого определения роли LLM, контекста задачи и ожидаемого стиля вывода.

**Пример Промпта (JavaScript - генерация кода в определенном контексте):\***

```markdown
Контекст: Ты - опытный backend-разработчик на Node.js, пишущий высокопроизводительный
и безопасный код для финансового приложения.
Требования: Ответ должен быть только в виде кода JavaScript, без лишних пояснений.

Задача: Напиши JavaScript функцию `calculateTransactionFee(amount, type)`,
которая рассчитывает комиссию за транзакцию. Для типа "international" комиссия 2%,
для "domestic" - 0.5%. Минимальная комиссия для любого типа - $1.
```

**Дополнительный Пример 1 (JavaScript - генерация тестов):**

Контекст: Ты - QA-инженер, пишущий модульные тесты для JavaScript-приложения
с использованием фреймворка Jest. Твоя цель - максимальное покрытие кода
и выявление пограничных случаев.
Требования: Предоставь только код тестов.

Задача: Напиши Jest-тесты для функции `parseDate(dateString)`, которая
принимает строку и возвращает объект Date. Учти валидные и невалидные форматы дат.

**Дополнительный Пример 2 (Анализ данных - интерпретация результатов):**

Контекст: Ты - дата-аналитик, представляющий результаты A/B теста маркетинговой кампании
нетехнической аудитории (менеджерам по продажам). Важно объяснить выводы просто и наглядно,
подчеркнув бизнес-значимость.
Требования: Ответ в виде краткого резюме (2-3 абзаца) и списка ключевых выводов.

Данные: Конверсия варианта A = 5.2%, Конверсия варианта B = 6.8%. P-value = 0.03.
Задача: Интерпретируй эти результаты.

**Влияние на JavaScript/Анализ данных:** Если вы просите LLM генерировать код для определенного фреймворка (React, Angular, Vue) или для специфической задачи анализа данных (например, "Ты — дата-сайентист, анализирующий временные ряды для выявления аномалий"), это сильно влияет на выбор библиотек, подходов и стиля кода.

### Formulating Requests with Answer Options / Output Space Restriction (Формулирование Запросов с Вариантами Ответов / Ограничение Выходного Пространства)

- **Источник:** ["Обратите внимание на разрыв уверенности"](https://arxiv.org/pdf/2409.12214) (особенно "Предоставление вариантов ответов")
- **Рейтинг:** 80
- **Адаптивность:** 85

**Суть метода:**
Исследование показывает, что предоставление LLM вариантов ответа (как в задачах с множественным выбором) или явное ограничение пространства возможных ответов может значительно повысить точность, особенно для менее крупных моделей, и улучшить калибровку их уверенности. Когда модель вынуждена выбирать из предложенного, это сужает её "пространство поиска" и снижает вероятность генерации ответа "из головы", который может быть неверным. Это также помогает модели лучше понять, какой тип ответа ожидается.

**Эффективность и Преимущества:**

- Повышает точность ответов, направляя модель: Модель фокусируется на выборе из предложенного, а не на генерации с нуля.
- Снижает вероятность генерации совершенно неверных или "галлюцинаторных" ответов: Ограничение выбора уменьшает "творческую свободу", которая может привести к ошибкам.
- Улучшает калибровку уверенности модели: Модель может быть более уверенной (и обоснованно) при выборе из ограниченного набора.
- Упрощает оценку ответа: Проверить правильность выбора из вариантов часто проще, чем оценить корректность свободно сгенерированного ответа.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Когда вам нужен конкретный ответ из ограниченного набора, или когда вы хотите проверить понимание моделью чего-либо.

**Пример Промпта (JavaScript - выбор подходящего метода массива):**

*Задача:* Какой метод массива JavaScript наиболее подходит для создания нового
массива, содержащего квадраты всех чисел из исходного массива?

Варианты ответов:
A) forEach()
B) map()
C) filter()
D) reduce()

Выбери один вариант и кратко объясни, почему он наиболее подходит.

**Дополнительный Пример (JavaScript - выбор типа ошибки):**

*Задача:* Пользователь вводит текстовое значение в поле, где ожидается число.
Какой тип ошибки JavaScript наиболее уместно сгенерировать в этом случае?

Варианты:
A) SyntaxError
B) TypeError
C) RangeError
D) ReferenceError

Выбери один вариант и объясни свой выбор.

**Дополнительный Пример (Анализ данных - выбор метрики):**

*Задача:* Для оценки модели классификации с несбалансированными классами,
какая метрика будет наиболее информативной, помимо точности (accuracy)?

Варианты:
A) Среднеквадратичная ошибка (MSE)
B) F1-мера
C) Коэффициент детерминации (R-squared)
D) Средняя абсолютная ошибка (MAE)

Выбери один вариант и кратко обоснуй.

### Principle Technique / Explicit Guiding Statements (Техника "Принципов" / Явное Задание Руководящих Утверждений)

- **Источник:** ["Оценка управляемости подсказок больших языковых моделей"](https://arxiv.org/pdf/2411.12405) (особенно "Техника 'Принципов'")
- **Рейтинг:** 85
- **Адаптивность:** 90

**Суть метода:**
Включение в начало промпта набора "принципов", "убеждений" или "руководящих утверждений", которым модель должна следовать при генерации ответа. Это позволяет "настроить" или "направить" поведение модели в соответствии с желаемой персоной или этической рамкой. Исследование показывает, что модели часто легче направить в сторону определенных этических или личностных значений, и что даже 1-3 таких утверждения могут существенно изменить ответ. Этот метод помогает преодолеть базовые "предпочтения" модели и сделать ее ответы более управляемыми.

**Эффективность и Преимущества:**

- Повышает управляемость (steerability) модели: Модель с большей вероятностью будет генерировать ответы, соответствующие заданным принципам.
- Позволяет получать более персонализированные, последовательные и предсказуемые ответы: Особенно полезно для создания контента с определенной точкой зрения или стилем.
- Полезно для создания контента в определенном стиле или с определенной точкой зрения: Например, для генерации кода, соответствующего строгим стандартам компании, или аналитических отчетов с акцентом на определенные аспекты.
- Обеспечивает большую согласованность ответов: При многократных запросах по схожим темам модель будет придерживаться ранее установленных принципов.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Задание стиля кодирования, принципов проектирования или этических рамок при генерации кода или аналитических выводов.

**Пример Промпта (JavaScript - генерация кода с принципами SOLID):**

Ты - опытный JavaScript-разработчик, придерживающийся принципов SOLID.
Принципы, которым ты следуешь:

1. Принцип единственной ответственности (Single Responsibility Principle): Каждый класс или модуль должен иметь только одну причину для изменения.
2. Принцип открытости/закрытости (Open/Closed Principle): Программные сущности должны быть открыты для расширения, но закрыты для модификации.
3. (и так далее, если нужно)

*Задача:* Разработай структуру классов на JavaScript для системы управления
заказами в интернет-магазине (например, классы Order, Product, Customer).
Убедись, что твоя реализация соответствует указанным выше принципам.
Кратко поясни, как каждый класс соответствует этим принципам.

**Дополнительный Пример (JavaScript - рефакторинг с акцентом на производительность):**

Ты - JavaScript-инженер, специализирующийся на оптимизации производительности.

Твои ключевые принципы при рефакторинге:
1. Минимизация количества операций в циклах.
2. Избегание ненужного создания объектов.
3. Использование наиболее эффективных встроенных методов для конкретной задачи.
4. Предпочтение асинхронных неблокирующих операций там, где это возможно.

*Задача*: Проанализируй следующую JavaScript функцию и предложи рефакторинг
для улучшения ее производительности, следуя указанным принципам. Объясни свои изменения.
[...код функции...]

**Дополнительный Пример (Анализ данных - интерпретация с принципом осторожности):**

Ты - дата-аналитик, который готовит отчет для принятия важных финансовых решений.

Твои принципы анализа:
1. Всегда указывай на ограничения данных и возможные источники погрешности.
2. Избегай категоричных выводов, если данные не полностью однозначны.
3. Подчеркивай потенциальные риски, связанные с каждым возможным решением, основанным на анализе.
4. Предпочитай консервативные оценки при прогнозировании.

*Задача:* Проанализируй следующий набор данных о продажах и подготовь резюме
о тенденциях и прогноз на следующий квартал, строго следуя указанным принципам.
[...описание набора данных или сами данные...]


### Multi-Sampling and Aggregation of Results (Мульти-сэмплинг и Агрегация Результатов)

- **Источник:** ["Генерация ключевых фраз без обучения"](https://arxiv.org/pdf/2503.00597) (стратегии агрегации) и принцип Self-Consistency
- **Рейтинг:** 82
- **Адаптивность:** 80 (требует нескольких запросов или настроек температуры)

**Суть метода:**
Генерация нескольких ответов на один и тот же промпт (возможно, с небольшими вариациями или повышенной "температурой" модели для большего разнообразия) и последующая их агрегация. Агрегация может быть выбором самого частого ответа (как в Self-Consistency), объединением, выбором лучшего по каким-то критериям.

**Эффективность и Преимущества:**

- Повышает надежность и точность ответов, особенно для задач, где есть несколько корректных решений или где модель может дать случайную ошибку.
- Снижает влияние случайных флуктуаций в генерации.
- Помогает выявить наиболее вероятный или консенсусный ответ.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Генерация вариантов рефакторинга JS кода: Попросить 3-5 вариантов рефакторинга функции и затем выбрать лучший.

**Пример Промпта (JavaScript - генерация нескольких вариантов функции):**

```markdown
Задача: Напиши JavaScript функцию для преобразования строки в kebab-case
(например, "helloWorld" -> "hello-world").

Сгенерируй 3 РАЗНЫХ, но корректных варианта реализации этой функции.
Для каждого варианта кратко опиши его подход.

(После получения ответов, пользователь может сам выбрать лучший или попросить LLM выбрать на основе критериев)
```

### Ensembling and Model Uncertainty Awareness (Ансамблирование и Учет Неопределенности Модели)

- **Источник:** ["Осведомленное объединение с учетом неопределенности (UAF)"](https://arxiv.org/pdf/2503.05757)
- **Рейтинг:** 78 (концептуально)
- **Адаптивность:** 75 (принципы адаптируемы, полная реализация сложна)

**Суть метода:**
Комбинирование ответов от нескольких разных LLM (или одной LLM с разными настройками/промптами) с учетом их предполагаемой точности или "уверенности" для конкретной задачи. Это может включать запрос модели оценить свою уверенность в ответе.

**Эффективность и Преимущества:**

- Снижает вероятность принятия неверной информации.
- Повышает фактическую точность, особенно для критически важных запросов.
- Дает лучшее понимание ограничений моделей и уровня доверия к их ответам.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Если у вас есть доступ к нескольким моделям, можно задать один и тот же вопрос (например, по сложной проблеме в JavaScript или интерпретации данных) нескольким моделям. Затем сравнить ответы. Можно также попросить одну модель оценить уверенность в своем ответе.

**Пример Промпта (имитация запроса на оценку уверенности):**

```markdown
Задача: Объясни разницу между `null` и `undefined` в JavaScript.

Пожалуйста, дай свой ответ и оцени свою уверенность в его полноте и точности
по шкале от 1 до 10 (где 10 - абсолютная уверенность).
Если твоя уверенность ниже 8, укажи, какие аспекты могут требовать дополнительного уточнения.
```

### Explicit Permission for Exceptions / Balance Between Rules and Flexibility (Явное Разрешение на Исключения / Баланс между Правилами и Гибкостью)

- **Источник:** ["Обучение ИИ обработке исключений"](https://arxiv.org/pdf/2503.02976)
- **Рейтинг:** 75
- **Адаптивность:** 85

**Суть метода:**
LLM часто слишком строго следуют правилам. Промпт должен явно указывать на возможность и разумность исключений из правил, если ситуация того требует, и запрашивать у модели объяснение такого решения.

**Эффективность и Преимущества:**

- Позволяет получать более гибкие и человекоподобные ответы в ситуациях, требующих нюансов.
- Избегает непрактичных или контрпродуктивных решений из-за слепого следования правилам.

**Практическое Применение и Адаптация для JS/Анализа данных:**
При запросе на применение каких-либо правил (стандарты кодирования, бизнес-логика, правила анализа данных), можно добавить указание на возможность обоснованных отступлений.

**Пример Промпта (JavaScript - применение eslint правил с возможными исключениями):**

```markdown
Задача: Проверь следующий фрагмент JavaScript кода на соответствие
правилам eslint-config-airbnb.

Код:
// ... фрагмент кода ...

ВАЖНО: Хотя ты должен стремиться к полному соответствию правилам, помни,
что в некоторых специфических ситуациях могут быть разумные исключения,
если строгое следование правилу ухудшает читаемость или производительность
без значимой пользы.
Если ты предлагаешь отступление от правила, ЧЕТКО ОБЪЯСНИ, почему это
оправдано в данном конкретном случае.

Укажи все несоответствия и предложи исправления или обоснованные исключения.
```

### Prompt Style Choice: Memorization vs. Generalization Focus (Выбор Стиля Промпта: Акцент на Меморизацию vs. Генерализацию)

- **Источник:** ["Обобщение против запоминания"](https://arxiv.org/pdf/2407.14985)
- **Рейтинг:** 70
- **Адаптивность:** 80

**Суть метода:**
Сознательный выбор формулировок промпта в зависимости от того, нужен ли точный ответ, основанный на запомненных данных (меморизация), или новое, обобщенное или креативное решение (генерализация).

**Эффективность и Преимущества:**

- Повышает точность фактических ответов при использовании "меморизующих" промптов.
- Стимулирует более креативные и оригинальные решения при использовании "генерализующих" промптов.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Нужен точный синтаксис JS функции из MDN? Формулируйте запрос близко к тому, как это описано в документации.

**Пример Промпта (JavaScript - акцент на генерализацию для новой идеи):**

```markdown
Задача: Предложи НОВУЮ и НЕСТАНДАРТНУЮ метафору для объяснения
концепции асинхронного программирования в JavaScript (Promises, async/await)
человеку, не знакомому с программированием, но любящему готовить еду.

Избегай стандартных объяснений про "официанта и заказ на кухне".
Подумай о процессе приготовления сложного блюда с несколькими этапами,
которые могут выполняться параллельно или последовательно.
Цель - максимальная наглядность и оригинальность.
```

### Accounting for LLM Interpretation of Subjective Language (Учет Особенностей Интерпретации LLM Субъективного Языка)

- **Источник:** ["Выявление недостатков в том, как люди и большие языковые модели интерпретируют субъективный язык"](https://arxiv.org/pdf/2503.04113) (метод TED)
- **Рейтинг:** 70 (концептуальное понимание)
- **Адаптивность:** 80 (осознанность при формулировании)

**Суть метода:**
LLM могут неожиданно интерпретировать субъективные инструкции ("энтузиастичный" текст может стать "нечестным", "остроумный" - "оскорбительным"). Важно понимать это и при необходимости использовать более конкретные, объективные формулировки вместо субъективных, если требуется предсказуемый результат.

**Эффективность и Преимущества:**

- Более предсказуемые ответы от LLM, когда важна точность тона или содержания.
- Снижение риска получения контента с нежелательными коннотациями.

**Практическое Применение и Адаптация для JS/Анализа данных:**
При запросе на генерацию текста (например, комментариев к JS коду, описаний для отчетов по данным), если важен определенный тон, лучше задать его через конкретные атрибуты, а не субъективные прилагательные.

**Пример Промпта (JavaScript - генерация комментариев с конкретикой вместо субъективности):**

```markdown
Задача: Напиши комментарии для следующей сложной JavaScript функции.

Функция:
function complexAlgorithm(data) { /_ ... много логики ... _/ }

Вместо того чтобы просить: "Напиши ПОЛЕЗНЫЕ и ПОНЯТНЫЕ комментарии."

Сформулируй так:
"Напиши комментарии для этой JavaScript функции, которые:

1. Объясняют НАЗНАЧЕНИЕ каждого основного блока кода.
2. Указывают на ВРЕМЕННУЮ СЛОЖНОСТЬ ключевых операций.
3. Предупреждают о возможных ГРАНИЧНЫХ СЛУЧАЯХ или НЕОЧЕВИДНОМ ПОВЕДЕНИИ.
4. Используют точные технические термины.
   Избегай общих или расплывчатых фраз.
```

## Advanced Prompt Engineering Techniques (Продвинутые Техники Промпт-Инжиниринга)

Этот раздел детализирует продвинутые техники промпт-инжиниринга, с анализом их эффективности и примерами адаптации для JavaScript и анализа данных.

### Causalized Chain of Thought (CauCoT) (Причинное CauCoT)

- **Рейтинг:** 75 (потенциально выше для сложных логических задач)
- **Адаптивность:** 75 (требует внимательного структурирования промпта)

**Суть метода:**
Метод CauCoT (Causalized Chain of Thought) делает рассуждения LLM не только правильными, но и понятными, моделируя причинно-следственные связи между шагами рассуждений с помощью структурных причинных моделей (SCM). Обычный CoT генерирует цепочку мыслей, но не всегда эти мысли логически и причинно связаны. CauCoT заставляет модель явно проверять и обосновывать причинные связи между каждым шагом. Это может включать использование ролевых запросов (например, "выступи в роли логика и проверь...") для исправления шагов, не имеющих причинных связей, обеспечивая как правильность, так и понятность всех шагов рассуждения.

**Эффективность и Преимущества:**

- **Значительно улучшает качество ответов языковых моделей:** Особенно в сложных задачах, требующих строгих логических выводов (математика, логические головоломки, отладка).
- **Делает процесс рассуждения модели более прозрачным и интерпретируемым:** Пользователь может проследить не просто последовательность шагов, а именно логическую связь между ними.
- **Помогает выявлять и исправлять ошибки в логической цепочке:** Явное требование причинности заставляет модель более тщательно проверять свои выводы.
- **Снижает вероятность нелогичных "скачков" в рассуждениях.**


**Практическое Применение и Адаптация для JS/Анализа данных:**
Этот подход особенно ценен для отладки сложных алгоритмов, анализа зависимостей в данных, построения объяснимых моделей машинного обучения или любой задачи, где важна строгая и понятная логика.

**Пример Промпта (JavaScript - отладка сложной логики):**

```markdown
Задача: Проанализировать и отладить JavaScript функцию,
которая неправильно рассчитывает итоговую скидку на товар.

Исходная (потенциально ошибочная) JavaScript функция:
```

```javascript
function calculateFinalPrice(basePrice, userType, promoCode, itemCategory) {
  let discount = 0;
  // Причина 1: Премиум скидка
  if (userType === 'premium') {
    discount += 0.1; // 10% для премиум
  }
  // Причина 2: Промокод (может быть, должен суммироваться, а не перезаписывать?)
  if (promoCode === 'SUMMER20') {
    discount = 0.2; // 20% по промокоду
  }
  // Причина 3: Скидка на категорию
  if (itemCategory === 'electronics' && basePrice > 1000) {
    discount += 0.05; // Дополнительные 5% на дорогую электронику
  }
  return basePrice * (1 - discount);
}
```

```markdown
Используй причинно-следственный подход (CauCoT) для анализа:

1.  **Разбей** логику функции на последовательные шаги применения скидок.
2.  Для каждого шага (применения скидки) явно **укажи ПРИЧИНУ** его выполнения
    (например, "Скидка 0.1 применяется, ПОТОМУ ЧТО userType 'premium'").
3.  **Проверь ПРИЧИННО-СЛЕДСТВЕННУЮ СВЯЗЬ** между шагами:
    - Как предыдущие скидки влияют на последующие?
    - Должны ли скидки суммироваться, выбираться максимальная, или применяться последовательно к уменьшающейся базе? (Это ключевой момент для выявления логических ошибок).
    - Обоснован ли порядок применения скидок?
4.  Если обнаружишь шаг, который **нелогично следует** из предыдущих или нарушает
    ожидаемое поведение (например, промокод полностью отменяет премиум-скидку,
    хотя они могли бы суммироваться), **отметь это как логический разрыв или ошибку**.
5.  **Предложи ИСПРАВЛЕННОЕ РАССУЖДЕНИЕ И КОД**, где каждый шаг причинно
    обоснован и соответствует предполагаемой логике (например, если скидки должны суммироваться,
    код должен отражать это).

Объясни свое рассуждение и предложи исправленный код.
Помни: каждый шаг должен быть ПРИЧИННО ОБОСНОВАН предыдущими шагами
и условиями задачи.
```

**Дополнительный Пример (JavaScript - анализ потока выполнения):**

*Задача:* Определить, почему JavaScript функция `processOrder` не отправляет email
в определенном сценарии.

[... код функции processOrder с несколькими условными блоками ...]

Сценарий: Заказ имеет статус "pending", сумма заказа > 100, у пользователя нет email.

*Инструкция CauCoT*:
"Проследи выполнение функции `processOrder` для данного сценария ШАГ ЗА ШАГОМ.
Для каждого условного оператора (if/else) объясни, ПОЧЕМУ выполняется та или иная ветка,
исходя из состояния переменных и предыдущих шагов.
Определи, на каком шаге и ПО КАКОЙ ПРИЧИНЕ не происходит вызов функции отправки email.
Если есть логическая ошибка в условиях, которая ПРИВОДИТ к этому, укажи ее."

**Дополнительный Пример (Анализ данных - объяснение модели):**

*Задача*: Объяснить, почему модель машинного обучения (например, дерево решений)
отнесла клиента X к сегменту "высокого риска оттока".

Входные данные: Характеристики клиента X, правила дерева решений.

*Инструкция CauCoT*:
"Пройдись по правилам дерева решений, применяя их к характеристикам клиента X.
На каждом узле дерева объясни, ПОЧЕМУ клиент X попадает в ту или иную ветку,
основываясь на его конкретных значениях признаков.
Покажи всю ПРИЧИННО-СЛЕДСТВЕННУЮ ЦЕПОЧКУ решений, которая ПРИВЕЛА
к классификации клиента X как "высокий риск оттока".
Убедись, что каждый переход логически обоснован."

### Structured CoT (Structure Search as part of System 2) (Структурный CoT (Structure Search как часть Системы 2))

- **Рейтинг:** 80
- **Адаптивность:** 85

**Суть метода:**
"Структурированное рассуждение (Structure Search)" – это часть перехода LLM к мышлению Системы 2 (медленному, аналитическому, в противовес быстрой интуитивной Системе 1). Реализуется через промпты, которые заставляют модель:
- Рассматривать проблему поэтапно: Декомпозировать сложную задачу на управляемые части.
- Исследовать несколько путей решения: Не останавливаться на первом пришедшем в "голову" варианте, а генерировать и оценивать альтернативы.
- Проверять промежуточные результаты: Перед тем как двигаться дальше, убедиться в корректности текущих выводов.
Это имитирует более вдумчивый человеческий подход к решению проблем.

**Эффективность и Преимущества:**

- Улучшает качество решений для сложных, многоэтапных задач: Особенно там, где требуется планирование или сравнение альтернатив.
- Помогает избежать преждевременных выводов и поверхностных решений.
- Делает процесс решения более управляемым и прозрачным: Пользователь может видеть, как модель пришла к выводу.
- Повышает надежность: За счет исследования альтернатив и проверки шагов.

**Практическое Применение и Адаптация для JS/Анализа данных:**
Идеально для проектирования архитектуры JavaScript-приложения, выбора оптимального алгоритма для анализа данных, декомпозиции сложной задачи на подзадачи или планирования последовательности действий.

**Пример Промпта (JavaScript - выбор структуры данных):**

```markdown
*Задача*: Выбрать оптимальную структуру данных в JavaScript для хранения
и быстрого поиска информации о пользователях по их ID и email.
Данные о пользователях включают: id, name, email, registrationDate.
Ожидаются частые операции поиска по ID и email, редкие добавления/удаления.

Используй структурированное рассуждение (Structure Search):

1.  **ПОЭТАПНЫЙ АНАЛИЗ ЗАДАЧИ:**
    *   Какие основные требования к структуре данных? (например, быстрый поиск по двум разным ключам, эффективное хранение)
    *   Какие операции будут выполняться наиболее часто? (поиск по ID, поиск по email)
    *   Какие операции будут редкими? (добавление, удаление)

2.  **ИССЛЕДОВАНИЕ АЛЬТЕРНАТИВНЫХ ПУТЕЙ РЕШЕНИЯ (минимум 3 варианта):**
    *   **Вариант A:** Использование одного `Map`, где ключ - `ID`, а значение - объект пользователя.
        *   *Промежуточный вопрос для проверки:* Как будет осуществляться эффективный поиск по `email` в этом случае?
    *   **Вариант B:** Использование двух `Map`: `usersById (id -> userObject)` и `usersByEmail (email -> userObject или email -> id)`.
        *   *Промежуточный вопрос для проверки:* Как обеспечить консистентность данных при добавлении/удалении пользователя?
    *   **Вариант C:** Использование массива объектов пользователей с созданием отдельных индексов (например, объектов, маппирующих `email` на индекс в массиве).
        *   *Промежуточный вопрос для проверки:* Какова будет сложность обновления индексов?

3.  **ОЦЕНКА КАЖДОЙ АЛЬТЕРНАТИВЫ И ПРОВЕРКА ПРОМЕЖУТОЧНЫХ ВЫВОДОВ:**
    *   Для каждого варианта оцени:
        *   Сложность реализации.
        *   Ожидаемая производительность операций поиска (по ID, по email) в терминах O-нотации.
        *   Ожидаемая производительность операций добавления/удаления.
        *   Потребление памяти.
    *   *Проверка:* Обоснованы ли твои оценки сложности и производительности для каждого варианта?

4.  **ВЫБОР ОПТИМАЛЬНОГО РЕШЕНИЯ И ОБОСНОВАНИЕ:**
    *   На основе проведенного анализа и оценок, выбери наиболее подходящую структуру данных.
    *   Подробно объясни, ПОЧЕМУ именно она является оптимальной для данной задачи, сравнивая ее с другими рассмотренными вариантами по ключевым критериям.
    *   Приведи краткий пример ее базовой реализации на JavaScript.
```

**Дополнительный Пример (JavaScript - планирование рефакторинга):**

*Задача*: У меня есть старый JavaScript модуль (около 500 строк) с большим количеством
глобальных переменных и тесно связанных функций. Его нужно рефакторить.

Используй структурированное рассуждение для создания плана рефакторинга:

1.  **ПОЭТАПНЫЙ АНАЛИЗ ПРОБЛЕМЫ:**
    *   Какие основные проблемы текущего кода? (глобальные переменные, сильная связанность, отсутствие модульности)
    *   Каковы цели рефакторинга? (улучшить читаемость, тестируемость, поддерживаемость)

2.  **ИССЛЕДОВАНИЕ АЛЬТЕРНАТИВНЫХ ПОДХОДОВ К РЕФАКТОРИНГУ (2-3 варианта):**
    *   **Подход A:** Преобразование в ES6 классы.
        *   *Промежуточная проверка:* Какие части текущей логики естественно ложатся на классы?
    *   **Подход B:** Разделение на функциональные модули (ESM).
        *   *Промежуточная проверка:* Как лучше всего сгруппировать существующие функции по ответственности?
    *   **Подход C:** Постепенный рефакторинг, начиная с изоляции наиболее критичных частей.
        *   *Промежуточная проверка:* Какие части являются наиболее критичными или проблемными?

3.  **ОЦЕНКА КАЖДОГО ПОДХОДА:**
    *   Оцени трудоемкость, риски и потенциальные выгоды каждого подхода.

4.  **ВЫБОР И ДЕТАЛИЗАЦИЯ ПЛАНА:**
    *   Выбери наиболее подходящий подход (или комбинацию) и предложи
        детализированный пошаговый план рефакторинга.


**Дополнительный Пример (Анализ данных - выбор модели машинного обучения):**

*Задача*: Выбрать модель машинного обучения для классификации текстов отзывов
(положительные/отрицательные). Есть 10,000 маркированных отзывов.

Используй структурированное рассуждение:

1.  **ПОЭТАПНЫЙ АНАЛИЗ ТРЕБОВАНИЙ:**
    *   Каковы характеристики данных (объем, язык, сбалансированность классов)?
    *   Каковы требования к производительности модели (точность, скорость обучения/предсказания)?

2.  **ИССЛЕДОВАНИЕ АЛЬТЕРНАТИВНЫХ МОДЕЛЕЙ (минимум 3):**
    *   **Модель A:** Логистическая регрессия на TF-IDF признаках.
    *   **Модель B:** Наивный Байес на TF-IDF признаках.
    *   **Модель C:** Fine-tuning предобученной трансформерной модели (например, BERT-tiny).
    *   *Промежуточная проверка для каждой:* Каковы ожидаемые плюсы и минусы этой модели для данной задачи?

3.  **ОЦЕНКА КАЖДОЙ МОДЕЛИ:**
    *   Оцени по критериям: простота реализации, требования к ресурсам, ожидаемая точность, интерпретируемость.

4.  **ВЫБОР И ОБОСНОВАНИЕ:**
    *   Выбери наиболее подходящую модель и объясни свой выбор,
        учитывая характеристики задачи и данные.


### Program-of-Thoughts (PoT) / Program-aided Language Models (PAL) (Программное размышление)

- **Рейтинг:** 85 (для задач, где код может помочь в рассуждении)
- **Адаптивность:** 70 (требует от LLM умения генерировать и понимать код)

**Суть метода:**
LLM не просто генерирует текстовое рассуждение, а пишет небольшую программу (например, на Python или JavaScript) для выполнения вычислений, логических операций, симуляций или манипуляций с данными как неотъемлемую часть своего мыслительного процесса. Вместо того чтобы пытаться "вычислить" ответ вербально (что часто приводит к ошибкам, особенно в математике), модель делегирует эту часть коду. Затем результат выполнения этой программы используется для формирования окончательного ответа или следующего шага рассуждения. Это позволяет сочетать сильные стороны LLM в понимании языка и генерации высокоуровневых планов с точностью и надежностью формальных вычислений.

**Эффективность и Преимущества:**

- **Значительно повышает точность:** Особенно в задачах, требующих точных математических вычислений, сложных логических шагов, работы со структурированными данными или симуляций.
- **Снижает вероятность арифметических и логических ошибок:** Код выполняется детерминированным интерпретатором, что исключает ошибки "невнимательности" LLM.
- **Позволяет решать более сложные задачи:** Некоторые задачи (например, включающие множество итераций или сложные математические формулы) практически невозможно решить только вербальными рассуждениями LLM.
- **Делает процесс решения верифицируемым:** Сгенерированный код можно проверить и выполнить отдельно.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- **Анализ данных:** LLM может написать JS-скрипт (или Python, если среда позволяет) для агрегации, фильтрации, трансформации или визуализации данных.
- **Решение математических или алгоритмических задач:** Генерация JS-кода для проверки гипотез, вычисления результатов, реализации алгоритмов.
- **Симуляции:** Создание простого JS-кода для моделирования какого-либо процесса или проверки поведения системы.
- **Работа с API:** Генерация кода для взаимодействия с внешними API и обработки их ответов.


**Пример Промпта (JavaScript - анализ данных о продажах):**

```markdown
Задача: Проанализировать данные о продажах и определить самый прибыльный товар.

Данные о продажах (массив JSON объектов):
```

```javascript
const salesData = [
  {productName: 'Laptop', quantity: 10, price: 1200, cost: 800},
  {productName: 'Mouse', quantity: 50, price: 25, cost: 10},
  {productName: 'Keyboard', quantity: 30, price: 75, cost: 35},
  {productName: 'Laptop', quantity: 5, price: 1200, cost: 800},
]
```

```markdown
Используй программное размышление (Program-of-Thoughts):

1.  **Сформулируй план решения на естественном языке:**
    *   Необходимо сгруппировать продажи по `productName`.
    *   Для каждого продукта рассчитать общую выручку (`totalRevenue = sum(quantity * price)`).
    *   Для каждого продукта рассчитать общую себестоимость (`totalCost = sum(quantity * cost)`).
    *   Для каждого продукта рассчитать общую прибыль (`totalProfit = totalRevenue - totalCost`).
    *   Найти продукт с максимальной `totalProfit`.

2.  **Напиши JavaScript код**, который реализует этот план для предоставленных `salesData`.
    Код должен выводить объект, где ключи - названия продуктов, а значения - их общая прибыль.
    Затем код должен определить и вывести название самого прибыльного продукта и его прибыль.

3.  **(Представь, что ты выполняешь этот код).** Покажи ожидаемый вывод этого кода.

4.  На основе результатов выполнения кода, **дай окончательный ответ**: какой товар самый прибыльный
    и какова его общая прибыль.

Пожалуйста, предоставь и план, и JavaScript код, и ожидаемый вывод, и финальный текстовый ответ.
```

**Дополнительный Пример (JavaScript - решение математической задачи):**

*Задача*: Найти сумму всех четных чисел от 1 до N (включительно).

Используй программное размышление:

1.  **План:** Написать JavaScript-функцию, которая принимает N, итерирует от 1 до N,
    проверяет каждое число на четность и суммирует четные.
2.  **Код:** Напиши эту функцию.
3.  **Тест:** Протестируй функцию для N=10. Покажи, какой результат вернет код.
4.  **Ответ:** На основе выполнения кода, дай ответ для N=10.

**Дополнительный Пример (Анализ данных - фильтрация и агрегация):**

*Задача*: Из списка сотрудников отфильтровать тех, кто работает в отделе 'Sales'
и имеет стаж более 3 лет, а затем посчитать их среднюю зарплату.

Данные:

```javascript
const employees = [
  {name: 'Alice', department: 'Sales', experience: 5, salary: 70000},
  {name: 'Bob', department: 'IT', experience: 2, salary: 60000},
  {name: 'Charlie', department: 'Sales', experience: 2, salary: 50000},
  {name: 'David', department: 'Sales', experience: 4, salary: 75000},
  {name: 'Eve', department: 'HR', experience: 6, salary: 65000},
];
```

Используй программное размышление:

1.  **План:**
    a. Отфильтровать массив `employees` по `department === 'Sales'` и `experience > 3`.
    b. Из отфильтрованного массива извлечь зарплаты.
    c. Рассчитать среднее значение этих зарплат.
2.  **Код:** Напиши JavaScript код для выполнения этого плана.
3.  **Вывод кода:** Какой результат вернет код (средняя зарплата)?
4.  **Ответ:** Сформулируй ответ на основе вывода кода.

**Примечание:** В этих примерах LLM делегирует вычисления и манипуляции данными коду, что значительно повышает надежность и точность.

### Tree of Thoughts (ToT) (Дерево Мыслей)

- **Рейтинг:** 80 (для исследовательских и сложных задач)
- **Адаптивность:** 70 (сложно полностью реализовать в простом чате, но принципы применимы)

**Суть метода:**
ToT обобщает Chain of Thought, позволяя LLM исследовать различные пути рассуждений ("ветви дерева") параллельно. На каждом шаге решения модель генерирует несколько промежуточных "мыслей" или частичных решений. Затем эти мысли оцениваются (самой моделью или с помощью эвристик), и выбираются наиболее обещающие для дальнейшего развития (генерации следующих мыслей). Это имитирует человеческое исследование различных вариантов решения, включая возможность "отката" (backtracking), если ветвь рассуждений заходит в тупик.

**Эффективность и Преимущества:**

- Улучшает решение сложных задач, где требуется исследование, планирование или нет очевидного линейного пути решения.
- Позволяет модели "отступать" от тупиковых путей рассуждений и исследовать другие варианты.
- Повышает качество генерируемых планов и решений за счет более широкого охвата пространства возможных решений.
- Более устойчив к ошибкам на промежуточных шагах, так как модель может переключиться на другую, более перспективную "ветвь".

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Проектирование сложных систем на JavaScript: Исследование различных архитектурных подходов, выбор технологий.
- Написание тестов для сложных или пограничных случаев: Генерация различных тестовых сценариев и оценка их эффективности.
- Поиск оптимальных путей в графах данных или сложных конфигурациях.
- Задачи творческого характера, где важно рассмотреть множество вариантов (например, разработка нескольких вариантов API).

**Пример Промпта (JavaScript - выбор JS фреймворка для проекта):**

```markdown
*Задача*: Выбрать наиболее подходящий JavaScript UI фреймворк (React, Vue, или Svelte)
для нового проекта: "Интерактивная образовательная платформа для детей с высокой
степенью кастомизации интерфейса и анимаций".

Используй принципы, схожие с Деревом Мыслей (Tree of Thoughts):

1.  **НАЧАЛЬНАЯ ТОЧКА (Корень дерева):** "Выбор JS UI фреймворка для детской платформы".

2.  **ГЕНЕРАЦИЯ ПЕРСПЕКТИВНЫХ ВАРИАНТОВ/КРИТЕРИЕВ (Первый уровень ветвления):**
    *   **Вариант 1: React.** *Ключевые мысли для развития:* Большая экосистема, много готовых UI-китов, потенциально высокий порог входа для сложных анимаций без доп. библиотек.
    *   **Вариант 2: Vue.** *Ключевые мысли для развития:* Мягкая кривая обучения, хорошая интеграция с анимационными библиотеками, директивы могут упростить кастомизацию.
    *   **Вариант 3: Svelte.** *Ключевые мысли для развития:* Компилятор, минимум бойлерплейта, встроенные возможности для анимаций, возможно, меньшее сообщество/экосистема по сравнению с React/Vue.

3.  **ИССЛЕДОВАНИЕ КАЖДОЙ ВЕТВИ (Второй уровень и глубже):**
    *   Для каждого фреймворка (React, Vue, Svelte) более детально рассмотри:
        *   **Легкость создания сложных анимаций:** Какие встроенные инструменты или популярные библиотеки есть? Насколько легко их интегрировать?
        *   **Кастомизация UI:** Насколько гибко можно изменять внешний вид и поведение компонентов?
        *   **Порог входа для команды:** Если команда состоит из junior/middle разработчиков.
        *   **Производительность на мобильных устройствах:** Важно для детских приложений.
    *   *Оценка каждой мысли:* Оцени перспективность каждой "мысли" (аспекта фреймворка) для данной задачи (например, по шкале от 1 до 5).

4.  **ОБСУЖДЕНИЕ "ТУПИКОВЫХ" ВЕТВЕЙ (Имитация отката):**
    *   Если какой-то фреймворк оказывается явно неподходящим по критическому параметру
        (например, крайне сложен для требуемых анимаций или имеет проблемы с производительностью),
        отметь это и объясни, почему дальнейшее его рассмотрение менее приоритетно.

5.  **ФИНАЛЬНЫЙ СИНТЕЗ И ВЫВОД:**
    *   Сравни наиболее перспективные "ветви" (фреймворки) по всем оцененным аспектам.
    *   Сделай аргументированный вывод, какой фреймворк является наилучшим выбором,
        и почему. Укажи возможные компромиссы или необходимые дополнительные инструменты.

Пожалуйста, структурируй свой ответ, явно отражая этот процесс исследования
различных путей и их оценки.
```

**Дополнительный Пример (JavaScript - разработка алгоритма):**

*Задача*: Разработать JavaScript алгоритм для поиска кратчайшего пути в лабиринте,
представленном двумерным массивом.

Инструкция (адаптация ToT):

```markdown
"Рассмотри несколько подходов к решению этой задачи:
1.  **Поиск в ширину (BFS):** *Мысль 1:* Как представить очередь? *Мысль 2:* Как отслеживать посещенные клетки? *Мысль 3:* Как восстановить путь?
2.  **Поиск в глубину (DFS):** *Мысль 1:* Как избежать зацикливания? *Мысль 2:* Как найти именно кратчайший путь, а не любой? (Может быть тупиковой для "кратчайшего" без модификаций).
3.  **Алгоритм A_ (A-star):** _Мысль 1:_ Какую эвристику использовать? _Мысль 2:_ Как управлять открытым и закрытым списками?

Для каждого подхода оцени сложность и применимость. Выбери лучший и объясни, почему.
Если какой-то подход кажется тупиковым для точного решения, объясни."
```

**Дополнительный Пример (Анализ данных - поиск причины аномалии):**

*Задача*: В данных по веб-трафику наблюдается резкое падение посещаемости сайта за последний час.
Нужно определить возможные причины.

Инструкция (адаптация ToT):

```markdown
"Рассмотри несколько КАТЕГОРИЙ возможных причин этого падения:
1.  **Технические проблемы с сайтом/сервером:**
    *   *Мысль 1.1:* Недоступность сервера. *Как проверить?*
    *   *Мысль 1.2:* Ошибки на сайте (JS-ошибки, ошибки 500). *Как проверить?*
2.  **Проблемы с источниками трафика:**
    *   *Мысль 2.1:* Сбой в рекламной кампании. *Как проверить?*
    *   *Мысль 2.2:* Проблемы с SEO / падение в поисковой выдаче. *Как проверить?*
3.  **Внешние события:**
    *   *Мысль 3.1:* Крупное новостное событие, отвлекшее аудиторию. *Как проверить?*
    *   *Мысль 3.2:* Проблемы у интернет-провайдеров в ключевых регионах. *Как проверить?*

Для каждой основной "мысли" предложи способ ее проверки.
Затем, основываясь на легкости проверки и вероятности, предложи наиболее
правдоподобные гипотезы и первоочередные шаги для диагностики."
```

**Примечание:** Прямая реализация ToT с автоматической оценкой ветвей сложна в стандартном чате. Однако, можно имитировать основной принцип: генерацию и исследование нескольких альтернативных путей рассуждений, их явную оценку и выбор наиболее перспективного.

### Contrastive Prompting (Контрастный Промптинг)

- **Рейтинг:** 78
- **Адаптивность:** 85

**Суть метода:**
Предоставление модели не только положительных примеров или инструкций (что нужно делать), но и отрицательных примеров или явных указаний на то, чего делать **не нужно** или чего следует избегать. Это помогает модели лучше понять границы желаемого ответа и отсечь нежелательные пути генерации. Контраст может быть выражен через:
-   Явные запреты ("НЕ используй...", "Избегай...").
-   Примеры того, что является неправильным или нежелательным.
-   Сравнение "хорошего" и "плохого" примера.ета.

**Эффективность и Преимущества:**

- **Повышает точность и управляемость генерации:** Модель получает более четкие рамки.
- **Снижает вероятность нежелательных выходов:** Помогает избежать генерации кода с антипаттернами, небезопасных конструкций, или текста с нежелательным тоном/содержанием.
- **Ускоряет получение нужного результата:** Меньше итераций на исправление, так как модель сразу "знает", чего делать не стоит.
- **Помогает обучить модель специфическим ограничениям задачи.**


**Практическое Применение и Адаптация для JS/Анализа данных:**

- **Генерация кода в определенном стиле:** "Пиши код в функциональном стиле. НЕ используй циклы for, предпочитай методы массивов map/filter/reduce."
- **Фильтрация данных:** "Отбери пользователей, которые активны за последний месяц. НЕ включай пользователей, которые были заблокированы или удалили свои аккаунты."
- **Избегание определенных библиотек или подходов:** "При решении этой задачи используй стандартные возможности JavaScript. НЕ ИСПОЛЬЗУЙ jQuery или Lodash."


**Пример Промпта (JavaScript - генерация кода с контрастными указаниями):**

```markdown
Задача: Напиши JavaScript функцию `getUserData(userId)`, которая получает данные
пользователя с сервера.

ПОЛОЖИТЕЛЬНЫЕ ИНСТРУКЦИИ (ЧТО ДЕЛАТЬ):

- Используй `async/await` для асинхронных операций.
- Используй `fetch` для HTTP-запросов.
- Обрабатывай возможные ошибки сети и ошибки ответа сервера (например, статус 404, 500).
- В случае ошибки возвращай `null` и логируй ошибку на стороне сервера (имитируй лог).
- Добавь JSDoc комментарии для функции, ее параметров и возвращаемого значения.

ОТРИЦАТЕЛЬНЫЕ ИНСТРУКЦИИ (ЧЕГО НЕ ДЕЛАТЬ):

- НЕ используй `XMLHttpRequest` или старые Promise-цепочки (`.then/.catch`).
- НЕ выбрасывай исключения (`throw error`) наружу из функции, обрабатывай их внутри.
- НЕ выводи детали ошибки пользователю, только общее сообщение или `null`.
- НЕ добавляй никакой UI логики, функция должна быть чисто для получения и обработки данных.
- НЕ используй сторонние библиотеки для HTTP-запросов (только встроенный `fetch`).

Пример URL: `/api/users/${userId}`
```

**Дополнительный Пример (JavaScript - написание чистого кода):**

*Задача*: Напиши JavaScript функцию `sumPositiveNumbers(arr)`, которая суммирует
только положительные числа в массиве.

Что нужно сделать:
- Функция должна быть чистой (не изменять входной массив).
- Использовать методы массивов (например, `filter` и `reduce`).
- Вернуть 0, если массив пуст или не содержит положительных чисел.

Чего НЕ нужно делать:
- НЕ использовать циклы `for` или `while`.
- НЕ модифицировать исходный массив `arr`.
- НЕ использовать глобальные переменные.

**Дополнительный Пример (Анализ данных - формулировка выводов):**

Данные: Отчет о продажах показывает рост на 15% в последнем квартале.
Задача: Сформулируй вывод для руководства.

Как нужно сформулировать:
- Кратко и по существу.
- С акцентом на положительную динамику.
- Упомянуть возможные факторы роста (если есть предположения).

Как НЕ нужно формулировать:
- НЕ использовать слишком оптимистичные или неподтвержденные прогнозы.
- НЕ вдаваться в излишние технические детали расчета.
- НЕ использовать жаргон, непонятный неспециалистам.
- НЕ приписывать весь успех одному фактору без достаточных оснований.


### Chain of Draft (CoD) / Iterative Refinement (Цепочка Черновиков)

- **Рейтинг:** 88
- **Адаптивность:** 90

**Суть метода:**
Это итеративный процесс:

- Черновик (Draft): LLM генерирует первоначальный ответ/код на основе начального запроса.
- Оценка (Evaluate): Пользователь (или другая LLM, выступающая в роли критика) оценивает черновик по заданным критериям, выявляет ошибки, неточности, слабые места или области для улучшения.
- Обратная связь (Feedback): Пользователь предоставляет модели конкретную обратную связь по результатам оценки.
- Улучшение (Refine): LLM получает обратную связь и генерирует улучшенную версию (новый черновик).
Этот цикл "Черновик -> Оценка -> Обратная связь -> Улучшение" может повторяться несколько раз, пока результат не достигнет желаемого качества.

**Эффективность и Преимущества:**

- Значительно улучшает качество сложных ответов: Позволяет постепенно дорабатывать решение, исправляя мелкие недочеты или крупные концептуальные ошибки.
- Позволяет постепенно приближаться к желаемому результату: Особенно полезно, когда трудно сразу сформулировать идеальный и исчерпывающий промпт.
- Хорошо подходит для задач, где важны нюансы или специфические требования, которые сложно учесть в одном промпте.
- Обучает пользователя лучше формулировать запросы и давать обратную связь.
- Может использоваться для решения задач, превышающих возможности модели в один проход.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Рефакторинг JavaScript кода: Сначала получить рабочий вариант, затем итеративно улучшать читаемость, производительность, соответствие стандартам.
- Создание сложных SQL-запросов или скриптов для анализа данных: Начать с простого запроса, затем добавлять условия, группировки, агрегации, оптимизировать.
- Написание технической документации или отчетов по анализу данных.
- Разработка сложных алгоритмов или архитектурных решений.

**Пример Промпта (JavaScript - создание сложного компонента):**

```markdown
*Задача*: Создать JavaScript компонент "Фильтруемый список товаров" с использованием React.

**ИТЕРАЦИЯ 1: БАЗОВЫЙ КОМПОНЕНТ**

Запрос:
"Пожалуйста, создай базовую структуру React компонента `ProductList` который:
1. Принимает массив `products` (каждый продукт - объект с `id`, `name`, `price`, `category`) через props.
2. Отображает каждый продукт (например, `product.name` и `product.price`).
3. Включает простое текстовое поле для ввода фильтра по названию товара."

(После получения ответа от LLM, пользователь его анализирует)

**ИТЕРАЦИЯ 2: ФИЛЬТРАЦИЯ И СОРТИРОВКА**
Обратная связь и Запрос на Улучшение:
"Отлично, базовый компонент есть. Теперь давай добавим функциональность:
1.  **Фильтрация:** Реализуй логику фильтрации списка товаров по тексту, введенному
    в текстовое поле. Фильтрация должна происходить по полю `product.name`
    и быть нечувствительной к регистру. Список должен обновляться динамически.
2.  **Сортировка:** Добавь две кнопки: 'Сортировать по цене (возр.)' и
    'Сортировать по цене (убыв.)'. При нажатии на них список товаров
    должен соответственно сортироваться.
3.  **Модульность:** Если возможно, вынеси отображение одного товара (`ProductItem`)
    в отдельный дочерний компонент.
Пожалуйста, предоставь обновленный код компонента `ProductList` (и `ProductItem`, если создан)."

(Цикл может продолжаться с добавлением пагинации, стилизации и т.д.)
```

**Дополнительный Пример (JavaScript - разработка утилиты):**

*Задача*: Написать утилиту на JavaScript для конвертации Markdown в HTML.

**Итерация 1 (Базовые элементы):**

```markdown
Запрос: "Напиши JS функцию `markdownToHtml(mdText)`, которая конвертирует
абзацы (текст, разделенный двойным переводом строки) и заголовки (#, ##, ###)
из Markdown в HTML"
```

(LLM генерирует код)

**Итерация 2 (Списки и ссылки):**

```markdown
Запрос: "Хорошо. Теперь добавь в функцию `markdownToHtml` поддержку
неупорядоченных списков (начинающихся с `-` или `*`) и ссылок (`[текст](url)`)."
```

(LLM генерирует обновленный код)
**Итерация 3 (Обработка жирного/курсивного текста):**

```markdown
Запрос: "Отлично. Финальное улучшение: добавь поддержку жирного текста
(`**текст**` или `__текст__`) и курсивного текста (`*текст*` или `_текст_`).
Убедись, что обработка вложенных стилей (например, жирный внутри ссылки) корректна."
```

**Дополнительный Пример (Анализ данных - построение отчета):**

*Задача*: Подготовить аналитический отчет по данным о пользовательской активности.

**Итерация 1 (Общая структура и ключевые метрики):**

```markdown
Запрос: "На основе этих данных [ссылка или описание данных], предложи структуру
аналитического отчета. Включи разделы: Обзор, Ключевые метрики (DAU, MAU, Retention Rate),
Основные выводы. Для раздела 'Ключевые метрики' предложи, как их рассчитать."
```

(LLM генерирует структуру и формулы)

**Итерация 2 (Визуализации и детальный анализ):**

```markdown
Запрос: "Структура хорошая. Теперь для раздела 'Ключевые метрики' предложи типы
визуализаций (например, линейный график для DAU/MAU, столбчатая диаграмма для Retention).
Для раздела 'Основные выводы' детализируй, какие именно выводы можно сделать,
исходя из гипотетических значений метрик (например, если DAU растет, а Retention падает)."
```	

(LLM генерирует дополнения)

**Итерация 3 (Рекомендации и оформление):**

Запрос: "Отлично. Добавь раздел 'Рекомендации' на основе сделанных выводов.
Также предложи краткие заголовки для каждого раздела и подраздела,
чтобы отчет был легко читаемым."

### Chain of Thought (CoT) (Цепочка Размышлений)

- **Рейтинг:** 90 (фундаментальный метод)
- **Адаптивность:** 95

**Суть метода:**
Побуждение LLM генерировать последовательность промежуточных шагов рассуждения перед тем, как дать окончательный ответ. Вместо того чтобы сразу выдавать результат, модель эксплицитно проговаривает (или "прописывает") логическую цепочку, которая привела ее к этому результату. Обычно активируется:

**Zero-shot CoT**: Добавлением простой фразы типа "Давай подумаем шаг за шагом" (Let's think step by step) к исходному запросу.

**Few-shot CoT**: Предоставлением нескольких примеров (few-shot examples), где каждый пример включает не только вопрос и ответ, но и детальное пошаговое рассуждение, приведшее к этому ответу. Модель затем следует этому паттерну для нового запроса.

**Эффективность и Преимущества:**

- Значительно улучшает способность LLM решать задачи, требующие многошаговых рассуждений: Это включает арифметические задачи, задачи на здравый смысл, логические выводы, символические манипуляции и др.
- Делает процесс мышления модели более явным и интерпретируемым: Позволяет понять, как модель пришла к ответу, и выявить возможные ошибки в ее "логике".
- Снижает количество ошибок, особенно тех, которые возникают из-за "поспешных" выводов.
- Позволяет моделям решать более сложные задачи, которые они не могли бы решить прямым ответом.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Универсально применим для любых сложных задач генерации или анализа кода/данных, где требуется логика, вычисления или последовательное применение правил.

**Пример Промпта (JavaScript - решение алгоритмической задачи):**

```markdown
Задача: Дана строка JavaScript кода. Определи, является ли использование
переменной `myVar` в последней строке безопасным (т.е. была ли она
объявлена и инициализирована в доступной области видимости).

Код:
```

```javascript
const codeSnippet = `
function exampleScope() {
  let x = 10;
  if (x > 5) {
    const myVar = "Hello";
    console.log(myVar);
  }
  // console.log(myVar); // Эта строка закомментирована, но представим, что мы ее анализируем
}
// Какая строка анализируется: console.log(myVar); (представим, что она раскомментирована ВНЕ функции)
`
```

```markdown
Проанализируй этот код и ответь на вопрос.
Давай подумаем шаг за шагом:

1. Где объявлена переменная `myVar`?
2. Какова область видимости этого объявления (`let`, `const` блочная область видимости)?
3. Находится ли анализируемая строка `console.log(myVar)` (ВНЕ функции)
   внутри области видимости `myVar`?
4. Сделай вывод о безопасности использования.
```

**Дополнительный Пример (JavaScript - вычисление значения):**

*Задача*: Есть JavaScript объект: `const data = {a: 5, b: {c: 10, d: 'Hello'}, e: [1, 2, 3]};`
Какое значение будет у `data.b.c * data.a + data.e[1]`?

Давай подумаем шаг за шагом:
1.  `data.b.c` равно 10.
2.  `data.a` равно 5.
3.  `data.e[1]` (второй элемент массива `e`) равно 2.
4.  Сначала выполняем умножение: `data.b.c * data.a` это `10 * 5 = 50`.
5.  Затем выполняем сложение: `50 + data.e[1]` это `50 + 2 = 52`.
Ответ: 52.


**Дополнительный Пример (Анализ данных - интерпретация метрики):**

*Задача*: В отчете по A/B тесту указано: p-value = 0.04, уровень значимости (alpha) = 0.05.
Следует ли отклонить нулевую гипотезу (H0), утверждающую, что между вариантами A и B нет разницы?

Давай подумаем шаг за шагом:
1.  Нулевая гипотеза (H0) утверждает, что нет статистически значимой разницы между вариантами.
2.  Альтернативная гипотеза (H1) утверждает, что разница есть.
3.  Уровень значимости (alpha) установлен на 0.05. Это порог для принятия решения.
4.  P-value, полученное в результате теста, равно 0.04.
5.  Правило принятия решения: Если p-value < alpha, то мы отклоняем H0 в пользу H1.
6.  В данном случае, 0.04 (p-value) < 0.05 (alpha).
7.  Следовательно, мы отклоняем нулевую гипотезу.
Ответ: Да, следует отклонить нулевую гипотезу.

### Self-Correction, Self-Refine, Self-Critique Methods (Методы самопроверки)

- **Рейтинг:** 88
- **Адаптивность:** 90

**Суть метода:**
Это группа техник, где LLM просят не только сгенерировать первоначальный ответ, но и затем:
**Self-Correction (Самоисправление)**: Найти и исправить конкретные ошибки (синтаксические, логические, фактические) в своем же ответе.
**Self-Refine (Самоулучшение)**: Итеративно улучшать свой ответ на основе общей инструкции или конкретных критериев (например, сделать его более ясным, полным, кратким, эффективным).
**Self-Critique (Самокритика)**: Оценить свой собственный ответ, выявить его слабые стороны, недостатки или потенциальные проблемы, даже если явных ошибок нет.
Эти процессы могут быть однократными или итеративными. Модель может использовать предоставленные критерии для критики или генерировать их сама.

**Эффективность и Преимущества:**

- Улучшает точность и надежность ответов: Модель активно ищет и исправляет свои недочеты.
- Помогает модели исправлять собственные ошибки, которые могли бы остаться незамеченными.
- Особенно полезно, когда нет четких внешних критериев для проверки или когда задача очень сложная.
- Повышает качество генерируемого контента по различным аспектам (ясность, полнота, стиль и т.д.).
- Может симулировать процесс обучения и обдумывания, свойственный человеку.

**Практическое Применение и Адаптация для JS/Анализа данных:**

После генерации JavaScript кода, можно попросить LLM:
- "Проверь этот код на наличие распространенных ошибок JavaScript, таких как ReferenceError или TypeError." (Self-Correction)
- "Предложи улучшения для этого кода с точки зрения читаемости и производительности, используя современные возможности ES6+." (Self-Refine)
- "Критически оцени это решение. Какие у него есть потенциальные узкие места, недостатки или случаи, когда оно может работать некорректно?" (Self-Critique)

**Пример Промпта (JavaScript - самопроверка сгенерированного кода):**

```markdown
Задача: Напиши JavaScript функцию, которая удаляет дубликаты из массива чисел,
сохраняя исходный порядок элементов.

**Шаг 1: Генерация первоначального ответа**
(Предположим, LLM сгенерировала следующую версию)
```

```javascript
function removeDuplicatesV1(arr) {
  const result = []
  for (let i = 0; i < arr.length; i++) {
    if (result.indexOf(arr[i]) === -1) {
      result.push(arr[i])
    }
  }
  return result
}
```

```markdown

**Шаг 2: Запрос на самокритику и улучшение**

"Спасибо за функцию `removeDuplicatesV1`.
Теперь, пожалуйста, выступи в роли опытного код-ревьюера и сделай следующее:

1.  **Самокритика (Self-Critique):**
    *   Какие потенциальные проблемы с производительностью есть у этой реализации, особенно для больших массивов?
    *   Насколько читаем этот код? Можно ли его упростить?
    *   Есть ли более идиоматичные или современные способы решения этой задачи в JavaScript?

2.  **Самоулучшение (Self-Refine):**
    *   Основываясь на своей критике, предложи улучшенную версию этой функции (`removeDuplicatesV2`).
    *   Новая версия должна быть более эффективной и/или более читаемой, сохраняя ту же функциональность (удаление дубликатов с сохранением порядка).
    *   Кратко объясни, какие изменения ты внес и почему они являются улучшением."

```

**Дополнительный Пример (JavaScript - рефакторинг с самокоррекцией):**

*Задача*: Дан следующий JavaScript код. Найди в нем потенциальные ошибки или антипаттерны и исправь их.

```javascript
var data = [];
for (i = 0; i < 5; i++) { // Отсутствует let/const для i
  data.push(function() { console.log(i); }); // Проблема с замыканием в цикле
}
data[0](); data[1](); // Ожидается 0, 1, но выведет 5, 5
```

Инструкция LLM:
"Проанализируй предоставленный JavaScript код.
1.  **Найди ошибки/проблемы (Self-Correction):** Какие проблемы есть в этом коде, связанные с областью видимости и замыканиями? Что он выведет и почему?
2.  **Предложи исправление:** Как можно исправить код, чтобы он выводил 0, а затем 1, как предполагалось?"


**Дополнительный Пример (Анализ данных - критика собственного вывода):**

*Задача*: На основе данных [описание данных о продажах] был сделан следующий вывод:
"Продажи продукта X выросли на 50% после запуска рекламной кампании Y, следовательно,
кампания Y была очень успешной и ее бюджет нужно удвоить."

Инструкция LLM:
"Выступи в роли скептического аналитика.
1.  **Самокритика (Self-Critique):** Какие логические пробелы или неучтенные факторы
    могут быть в этом выводе? Является ли причинно-следственная связь "кампания Y -> рост продаж"
    однозначно доказанной? Какие альтернативные объяснения роста продаж возможны?
    Какие дополнительные данные нужны для подтверждения вывода об успехе кампании?
2.  **Сформулируй более осторожный и обоснованный вывод.**"


### Chain-of-Verification (CoV) (Цепочка Верификаций)

- **Рейтинг:** 85
  **Адаптивность:** 80 (требует внимательного формулирования проверочных вопросов)

**Суть метода:**
CoV — это многоэтапный процесс, направленный на снижение галлюцинаций и повышение фактической точности ответов LLM. Он включает:

- Генерация базового ответа: LLM дает первоначальный ответ на запрос.
- Планирование верификации: LLM генерирует набор верификационных вопросов, которые она должна задать самой себе, чтобы проверить различные утверждения, содержащиеся в ее базовом ответе.
- Выполнение верификации: LLM последовательно отвечает на эти верификационные вопросы. Это может включать как обращение к своим внутренним знаниям, так и (в идеале) поиск информации во внешних источниках (хотя в стандартном чате это имитируется).
- Генерация финального, проверенного ответа: LLM интегрирует результаты верификации для корректировки и улучшения своего первоначального ответа.

**Эффективность и Преимущества:**

- Значительно снижает галлюцинации и фактические ошибки: За счет явной проверки утверждений.
- Улучшает точность ответов, особенно для фактологических запросов или задач, требующих синтеза информации из разных источников.
- Делает процесс проверки более явным и структурированным.
- Повышает доверие к ответам модели, так как они проходят через этап "фактчекинга".

**Практическое Применение и Адаптация для JS/Анализа данных:**

- Проверка документации или описаний для JavaScript библиотеки/фреймворка: Сгенерировать описание, затем верификационные вопросы к этому описанию, затем улучшить описание.
- Анализ данных со сложными выводами: Сделать первоначальный вывод, затем сформулировать вопросы для проверки этого вывода по данным или известным фактам, затем уточнить вывод.
- Объяснение сложных концепций: Сначала дать объяснение, потом проверить его на полноту, точность и наличие потенциальных недопониманий.

**Пример Промпта (JavaScript - объяснение концепции с CoV):**

```markdown
Задача: Объясни концепцию "замыканий" (closures) в JavaScript для начинающего,
который знаком только с основами функций и переменных.

Используй метод Цепочки Верификаций (Chain-of-Verification):

1.  **ПЕРВОНАЧАЛЬНЫЙ ОТВЕТ (Базовое объяснение):**
    *   Сначала дай простое и понятное объяснение замыканий в JavaScript,
        приведя один небольшой пример кода.

2.  **ПЛАНИРОВАНИЕ ВЕРИФИКАЦИИ (Генерация проверочных вопросов к твоему объяснению):**
    *   Теперь, к своему первоначальному ответу, составь 3-4 верификационных вопроса,
        которые помогут проверить его точность и полноту. Например:
        *   "Действительно ли переменные из внешней функции доступны во внутренней функции *после* того, как внешняя функция завершила свою работу?"
        *   "Создается ли новое замыкание при каждом вызове внешней функции, или оно одно на все вызовы?"
        *   "Какие конкретные преимущества или практические применения замыканий я должен упомянуть для начинающего?"
        *   "Достаточно ли прост и понятен мой пример кода для новичка?"

3.  **ВЫПОЛНЕНИЕ ВЕРИФИКАЦИИ (Ответы на свои же вопросы):**
    *   Последовательно ответь на каждый из этих верификационных вопросов,
        ссылаясь на свое первоначальное объяснение или дополняя его.
        Если обнаружишь неточность или пробел, отметь это.

4.  **ФИНАЛЬНЫЙ УЛУЧШЕННЫЙ ОТВЕТ:**
    *   На основе проведенной верификации и ответов на вопросы, предоставь
        окончательное, более точное, полное и понятное для начинающего
        объяснение замыканий в JavaScript, включая улучшенный или дополнительный пример кода,
        если это необходимо.
```

**Дополнительный Пример (JavaScript - описание новой фичи языка):**

*Задача*: Описать новую фичу JavaScript "Optional Chaining (`?.`)" для разработчика,
который с ней не знаком.

Инструкция CoV:
1.  **Базовый ответ:** Кратко опиши, что такое Optional Chaining и для чего он нужен. Приведи пример.
2.  **Верификационные вопросы (сгенерируй их):**
    *   Работает ли `?.` только со свойствами объектов или также с вызовами функций и доступом к элементам массива?
    *   Что возвращается, если цепочка "обрывается" (свойство/метод не существует)?
    *   Можно ли использовать `?.` в левой части присваивания?
3.  **Ответы на вопросы:** Дай ответы на сгенерированные вопросы.
4.  **Улучшенный ответ:** Предоставь полное описание Optional Chaining, учитывая ответы на верификационные вопросы.


**Дополнительный Пример (Анализ данных - интерпретация статистического теста):**

*Задача*: Объяснить результаты t-теста для двух независимых выборок не-статистику.

Результаты: t-статистика = 2.5, p-value = 0.015, df = 98.
Сравниваются средние значения для группы A и группы B.

Инструкция CoV:
1.  **Базовый ответ:** Кратко объясни, что показывают эти результаты.
2.  **Верификационные вопросы (сгенерируй их):**
    *   Говорит ли p-value < 0.05 о статистически значимой разнице?
    *   Что означает "статистически значимая разница" простыми словами?
    *   Можем ли мы на основе этих данных сказать, какая группа (A или B) имеет *большее* среднее?
    *   Какие допущения у t-теста, о которых стоит упомянуть?
3.  **Ответы на вопросы:** Дай ответы.
4.  **Улучшенный ответ:** Предоставь полное и понятное объяснение результатов t-теста для не-статистика.

### Word / Block Order in Prompts (Порядок слов/блоков в промптах)

- **Рейтинг:** 70-80 (зависит от модели и сложности задачи)
- **Адаптивность:** 90

**Суть метода:**

Порядок, в котором информация (инструкции, контекст, примеры, вопросы) представлена в промпте, может влиять на то, как LLM интерпретирует задачу и генерирует ответ.

- **Контроль разнообразия**: Показало, что порядок блоков промпта (например, базовая информация, память о предыдущих диалогах, окружение, текущий диалог) и частота упоминания имен/сущностей существенно влияют на разнообразие ответов в диалоговых симуляциях. Хронологический порядок информации (от общего к частному, или от более ранних событий к более поздним) часто дает более предсказуемые и менее разнообразные (если это цель) ответы. Наоборот, нарушение хронологии или помещение менее релевантной информации в начало может увеличить разнообразие.
- **Исследование #120 (HPSS для LLM-оценщиков)**: Выявило, что порядок компонентов в промпте, предназначенном для оценки (например, шкала оценки, примеры для сравнения, критерии оценки, цепочка мыслей для оценщика), влияет на качество и согласованность оценок, выдаваемых LLM. Рекомендуется, например, размещать описание задачи и основные инструкции в начале для создания логической структуры.

**Эффективность и Преимущества:**

- Может влиять на фокус модели: То, что упомянуто раньше (или позже, в зависимости от архитектуры модели и феномена "lost in the middle"), может получить больше внимания.
- Может влиять на последовательность рассуждений и структуру вывода: Если промпт структурирован логически, ответ модели, скорее всего, тоже будет более структурированным.
- Правильный порядок может улучшить понимание моделью контекста и задачи, особенно для длинных и сложных промптов.
- Может помочь управлять детализацией или специфичностью ответа.

**Практическое Применение и Адаптация для JS/Анализа данных:**

- **Общее правило:**
- Наиболее важные инструкции, ограничения или ключевой контекст часто лучше размещать либо в самом начале промпта (чтобы задать тон и рамки), либо непосредственно перед основным вопросом/задачей.
- Избегайте помещения критически важной информации в середину очень длинного промпта из-за проблемы "lost in the middle" (хотя техники типа Pause-Tuning из исследования #188 могут помочь с этим).

**Для генерации кода JavaScript:**

- Сначала контекст и глобальные ограничения, затем конкретная задача.

- **Контекст:** Я разрабатываю веб-приложение на React с использованием TypeScript.
- **Стиль кода:** Функциональные компоненты с Hooks. Строгая типизация обязательна.
- **Избегай:** Использования `any` типа без крайней необходимости.
- **Задача:** Напиши компонент `UserProfileCard`, который принимает объект `user`
(с полями `id: number, name: string, avatarUrl?: string`) и отображает его.

Примеры (если используются) лучше давать до основной задачи, чтобы модель "настроилась" на нужный паттерн.

**Для анализа данных:**

- Сначала определение данных или их структуры, затем инструкции по анализу.

- **Данные:** Представлены в виде массива JavaScript объектов следующей структуры:
`{ date: 'YYYY-MM-DD', category: string, value: number }`
- Пример: `[{date: '2023-01-15', category: 'A', value: 100}, ...]`

- *Задача:* Проанализируй эти данные и рассчитай сумму `value` для каждой `category` за январь 2023 года.
Представь результат в виде объекта, где ключ - категория, значение - сумма.

- Если промпт для LLM-оценщика (как в HPSS), то сначала четкое описание задачи оценки, затем критерии, потом шкала, потом примеры, потом оцениваемый объект.

**Пример Промпта (JavaScript - порядок для сложной задачи генерации):**

**Вариант 1: Основная задача в конце**

- *Ты - эксперт по безопасности веб-приложений.*
- *Твоя задача - проанализировать следующий фрагмент JavaScript кода на предмет потенциальных уязвимостей типа XSS (Cross-Site Scripting).*

- **Контекст кода:** Код отвечает за отображение комментариев пользователей на странице.
- **Данные:** (переменная `userInput`) приходят от пользователя и могут содержать HTML-теги.

- **Критерии анализа:**
1.  Идентифицируй все места, где `userInput` или его производные вставляются в DOM.
2.  Определи, используется ли адекватная санация (экранирование) этих данных.
3.  Если уязвимость найдена, опиши ее и предложи безопасный способ исправления.

- **Формат ответа:**
- Список уязвимых участков кода.
- Описание уязвимости для каждого участка.
- Рекомендации по исправлению с примерами безопасного кода.

- **Фрагмент кода для анализа:**

function displayComment(userInput) {
  const commentDiv = document.getElementById('comments');
  commentDiv.innerHTML += `<div>${userInput}</div>`; // Потенциальная XSS
}

**Вариант 2: Основная задача в начале (может быть менее эффективно для задания контекста)**

function displayComment(userInput) {
  const commentDiv = document.getElementById('comments');
  commentDiv.innerHTML += `<div>${userInput}</div>`;
}

- **Ты - эксперт по безопасности веб-приложений.**
- **Контекст кода:** Код отвечает за отображение комментариев пользователей на странице.
- **Данные:** (переменная `userInput`) приходят от пользователя и могут содержать HTML-теги.
- **Критерии анализа:** ...
- **Формат ответа:** ...


**Дополнительный Пример 1 (JavaScript - генерация функции с несколькими требованиями):**

**Промпт с логическим порядком блоков:**

1. Роль, 2. Задача, 3. Ключевые требования, 4. Ограничения, 5. Формат вывода

- *Ты - опытный JavaScript-разработчик.*
- *Задача:* Напиши функцию `formatDate(date, formatString)`, которая принимает
объект `Date` и строку формата, и возвращает отформатированную дату.

**Ключевые требования:**
- Поддерживаемые форматы в `formatString`: 'YYYY-MM-DD', 'DD/MM/YYYY HH:mm'.
- Функция должна корректно обрабатывать однозначные месяцы/дни (например, '2023-01-05').

**Ограничения:**
- НЕ используй сторонние библиотеки для работы с датами (например, Moment.js, date-fns).
- Реализуй логику форматирования самостоятельно.

**Формат вывода:** Только код функции с JSDoc комментариями.


**Дополнительный Пример 2 (Анализ данных - многошаговый анализ):**

**Промпт с четкой последовательностью шагов анализа:**
1. Описание данных, 2. Шаг 1 анализа, 3. Шаг 2 анализа, ..., N. Финальный вывод

Данные: Массив объектов, каждый объект `{id: number, timestamp: ISOString, event_type: string, user_id: string}`.
Представляют собой лог пользовательских событий.

**Анализ:**
1.  Сначала сгруппируй события по `user_id`.
2.  Для каждого пользователя рассчитай количество событий типа 'login' и 'purchase'.
3.  Затем, определи пользователей, у которых было > 2 логинов и хотя бы 1 покупка.
4.  Представь результат в виде массива `user_id` таких пользователей.

**Пожалуйста, выполни этот анализ.**

**Примечание:** Эффект порядка слов/блоков может быть не всегда очевиден и часто требует экспериментов с конкретной моделью и задачей. Однако, следование логической структуре и размещение наиболее важных инструкций на видных местах (начало/конец) обычно является хорошей практикой. Исследования показывают, что модели могут быть чувствительны к этому, и продуманный порядок может улучшить как понимание задачи
