---
title: JavaScript Fundamentals
---

## Advanced Expressions

### Data types: Primitives vs Objects

В JavaScript все значения делятся на две большие категории: **примитивные типы** (primitives) и **объекты** (objects).

#### Primitives types

К примитивам относятся:

- **string** — строки (`'hello'`, `"world"`)
- **number** — числа (`42`, `3.14`, `NaN`)
- **bigint** — большие целые числа (`123n`)
- **boolean** — булевы значения (`true`, `false`)
- **undefined** — специальное значение, означающее "не определено"
- **null** — специальное значение "ничего", "пусто"
- **symbol** — уникальные идентификаторы (`Symbol('id')`)

**Особенности:**

- Примитивы неизменяемы (immutable): если вы меняете значение, вы создаёте новый примитив.
- Примитивы сравниваются по значению.
- Примитивы не имеют методов и свойств, но при обращении к ним временно создаётся объект-обёртка (например, `'abc'.toUpperCase()`).

#### Objects

К объектам относятся:

- Обычные объекты (`{}`), массивы (`[]`), функции, а также встроенные объекты (`Date`, `RegExp`, и др.)

**Особенности:**

- Объекты изменяемы (mutable): их свойства можно менять после создания.
- Объекты сравниваются по ссылке, а не по значению.
- Объекты могут содержать любые типы данных в качестве свойств.

#### Examples:

```javascript
// Primitives
let a = 5
let b = a
b = 10
console.log(a) // 5 (a не изменился)

// Объекты
let obj1 = {value: 5}
let obj2 = obj1
obj2.value = 10
console.log(obj1.value) // 10 (obj1 и obj2 ссылаются на один объект)
```

**Важно:**

- Операции с примитивами всегда работают с копией значения.
- Операции с объектами работают с ссылкой на объект.

### Ternary, Nullish Coalescing, Optional Chaining, and Logical Operators

#### Ternary operator

Тернарный оператор — это короткая форма записи условного выражения:

```javascript
const age = 18
const status = age >= 18 ? 'adult' : 'minor'
console.log(status) // 'adult'
```

#### Nullish Coalescing `??`

Возвращает правый операнд, если левый равен `null` или `undefined`:

```javascript
const name = null
const displayName = name ?? 'Guest'
console.log(displayName) // 'Guest'

const value = 0
console.log(value ?? 42) // 0 (в отличие от ||, 0 не считается "пустым")
```

#### Optional Chaining `?.`

Позволяет безопасно обращаться к вложенным свойствам объектов, не вызывая ошибку, если промежуточное значение `null` или `undefined`:

```javascript
const user = {profile: {name: 'Alice'}}
console.log(user.profile?.name) // 'Alice'
console.log(user.address?.city) // undefined (ошибки нет)
```

#### Logical operators (`&&`, `||`, `!`)

- `&&` (И): возвращает первый "ложный" операнд или последний, если все истинны.
- `||` (ИЛИ): возвращает первый "истинный" операнд.
- `!` (НЕ): инвертирует булево значение.

**Примеры:**

```javascript
console.log(0 || 'default') // 'default'
console.log('hello' && 123) // 123
console.log(!false) // true
```

### Type conversions, == / ===

#### Implicit and explicit type conversions

JavaScript автоматически преобразует типы в некоторых выражениях (coercion), но можно делать это явно:

```javascript
console.log(Number('42')) // 42
console.log(String(123)) // '123'
console.log(Boolean(0)) // false
```

**Неявные преобразования:**

```javascript
console.log('5' * 2) // 10 (строка '5' преобразуется в число)
console.log('5' + 2) // '52' (число 2 преобразуется в строку)
console.log(!!'hello') // true (строка преобразуется в boolean)
```

#### Comparison operators: `==` vs `===`

- `==` (нестрогое сравнение): приводит типы к одному и сравнивает значения.
- `===` (строгое сравнение): сравнивает и тип, и значение.

**Примеры:**

```javascript
console.log(0 == false) // true
console.log(0 === false) // false

console.log('' == 0) // true
console.log('' === 0) // false

console.log(null == undefined) // true
console.log(null === undefined) // false
```

### Understanding Object.is (optional)

`Object.is()` — это метод в JavaScript, который предназначен для сравнения двух значений на строгое равенство. Хотя он работает схоже с оператором `===`, есть некоторые важные различия. `Object.is()` считает NaN равным NaN, что отличается от поведения `===`, который считает `NaN` не равным самому себе. Кроме того, `Object.is()` различает `-0` и `+0`, которые считаются равными при использовании `===`.

Эти особенности делают `Object.is()` полезным в ситуациях, где требуется более точное сравнение значений, чем то, что предлагает `===`.

**Samples:**

```javascript
console.log(Object.is(NaN, NaN)) // true
console.log(NaN === NaN) // false

console.log(Object.is(-0, +0)) // false
console.log(-0 === +0) // true
```

### Differences between let, var, and const

В JavaScript существуют три способа объявления переменных: `var`, `let`, и `const`. Каждый из них имеет свои особенности, которые важно понимать при разработке:

- **`var`:**

  - **Область видимости:** Функциональная, то есть переменная, объявленная с `var`, доступна в пределах функции, в которой она объявлена, или глобально, если объявлена вне функции.
  - **Hoisting (поднятие):** Объявления переменных с использованием `var` поднимаются в начало своей области видимости, но не их инициализация.
  - **Повторное объявление:** Разрешено повторное объявление одной и той же переменной в пределах одной области видимости.

- **`let`:**

  - **Область видимости:** Блочная, то есть переменная доступна только в пределах блока `{}`, в котором она объявлена.
  - **Hoisting:** Переменные, объявленные с `let`, поднимаются в начало блока, но к ним нельзя обращаться до инициализации из-за временной мертвой зоны (TDZ).
  - **Повторное объявление:** Повторное объявление одной и той же переменной в одной и той же области видимости вызовет ошибку.

- **`const`:**
  - **Область видимости:** Также блочная, как и у `let`.
  - **Hoisting:** Ведет себя аналогично `let` с точки зрения поднятия.
  - **Неизменяемость:** Значение переменной, объявленной с помощью const, нельзя переназначить после инициализации. Однако, если const используется для объявления объекта, свойства этого объекта могут изменяться.

**Samples:**

```javascript
{
  var a = 1
  let b = 2
  const c = 3
}
console.log(a) // 1
console.log(b) // ReferenceError: b is not defined
console.log(c) // ReferenceError: c is not defined

const obj = {prop: 1}
obj.prop = 2 // Допустимо, свойства объекта могут изменяться
obj = {} // TypeError: Assignment to a constant variable
```

### Exploring the Temporal Dead Zone

Временная мертвая зона (TDZ) — это концепция в JavaScript, связанная с `let` и `const`. TDZ — это период времени между моментом, когда переменная объявляется в области видимости, и моментом её фактической инициализации. В этот период любая попытка обратиться к переменной приводит к ошибке `ReferenceError`.

Важно понимать, что TDZ существует только для `let` и `const`.
`var` не подвержен этой концепции, так как его значение поднимается и инициализируется как `undefined`.

**Samples:**

```javascript
console.log(x) // ReferenceError: Cannot access 'x' before initialization
let x = 5

// В отличие от:
console.log(y) // undefined
var y = 5
```

### Concepts of Hoisting

Hoisting (поднятие) — это механизм в JavaScript, при котором объявления переменных и функций поднимаются в начало их области видимости перед выполнением кода. Важно понимать, что поднимаются именно объявления, но не инициализации.

Для `var` переменных поднимается объявление, но не их присвоенное значение, поэтому до момента инициализации они имеют значение `undefined`. Для переменных, объявленных с `let` и `const`, происходит подъем объявления, но их инициализация остаётся на своём месте, поэтому до момента инициализации они находятся в TDZ.

Функции, объявленные с использованием `function`, полностью поднимаются, включая их тело, что позволяет вызывать их до момента их фактического объявления в коде.

**Samples:**

```javascript
console.log(x) // undefined
var x = 5

// Эквивалентно:
var x
console.log(x) // undefined
x = 5

// Функции также поднимаются:
hello() // "Hello, World!"
function hello() {
  console.log('Hello, World!')
}
```

### The Role of Polyfills

Полифилы — это куски кода (обычно функции), которые реализуют возможности нового стандарта JavaScript в старых окружениях, которые эти возможности не поддерживают. Полифилы позволяют разработчикам использовать новейшие функции языка, не беспокоясь о том, что их код не будет работать в старых браузерах.

Полифилы часто используются для добавления поддержки таких методов, как `Array.prototype.includes`, `Promise`, или даже `fetch` в браузерах, где они не реализованы.

**Samples** полифила для метода `Array.prototype.includes`:

```javascript
if (!Array.prototype.includes) {
  Array.prototype.includes = function (searchElement, fromIndex) {
    if (this == null) {
      throw new TypeError('"this" is null or not defined')
    }
    var o = Object(this)
    var len = o.length >>> 0
    if (len === 0) {
      return false
    }
    var n = fromIndex | 0
    var k = Math.max(n >= 0 ? n : len - Math.abs(n), 0)
    while (k < len) {
      if (o[k] === searchElement) {
        return true
      }
      k++
    }
    return false
  }
}
```

## Functions

### Differences and Uses of Arrow Functions, Function Expressions, and Function Declarations

**1. Function Declaration:**

Function Declaration (объявление функции) - это классический способ определения функции в JavaScript.

- **Hoisting (Поднятие):** Объявление функций поднимается в начало своей области видимости, что позволяет вызывать функцию до её объявления в коде.
- **Контекст (this):** Function declaration имеет собственный контекст `this`, который определяется в момент вызова функции.
- **Использование как конструктор:** Функция, объявленная через function declaration, может использоваться как конструктор для создания объектов с помощью ключевого слова `new`.

```javascript
// Можно вызвать до объявления благодаря hoisting
console.log(sum(2, 3)) // Выведет: 5
function sum(a, b) {
  return a + b
}

// Использование в качестве конструктора
function Person(name) {
  this.name = name
}

const john = new Person('John')
console.log(john.name) // Выведет: John
```

**2. Function Expression:**

Function Expression (функциональное выражение) - это функция, которая может быть частью выражения, например, присвоена переменной.

- **Hoisting:** В отличие от function declaration, function expression не поднимается, поэтому её нельзя вызывать до того, как она была объявлена.
- **Контекст (this):** Имеет собственный контекст `this`, аналогично function declaration, контекст может быть изменён при передаче функции в другие части кода.
- **Использование как конструктор:** Function expression также может использоваться как конструктор, если она не является стрелочной функцией.

```javascript
// Нельзя вызвать до объявления
console.log(multiply(2, 3)); // Вызовет ошибку: multiply is not a function
const multiply = function(a, b) {
	return a b;
};

console.log(multiply(2, 3)); // Выведет: 6

// Использование в качестве метода объекта
const calculator = {
	operation: "Multiplication",
	calculate: function(a, b) {
	console.log(${this.operation} result: ${a * b});
}

};
calculator.calculate(2, 3); // Выведет: Multiplication result: 6
```

**3. Arrow Function:**

Arrow Function (стрелочная функция) - это более краткий синтаксис для написания функций, введенный в ES6.

- **Hoisting:** Как и function expression, стрелочные функции не поднимаются, и их нужно объявлять до использования.
- **Контекст (this):** Стрелочные функции не имеют собственного контекста `this`. Вместо этого они используют `this` из окружающего лексического окружения. Это делает их удобными для использования в методах или вложенных функциях, где важно сохранить контекст внешней функции.
- **Использование как конструктор:** Стрелочные функции не могут использоваться как конструкторы, и попытка вызвать их с `new` приведет к ошибке.
- **Более краткий синтаксис:** Стрелочные функции имеют лаконичный синтаксис, что делает их удобными для простых выражений.

```javascript
const divide = (a, b) => a / b;
console.log(divide(6, 2)); // Выведет: 3

// Использование в колбэках
const numbers = [1, 2, 3, 4, 5];
const squaredNumbers = numbers.map(num => num num);
console.log(squaredNumbers); // Выведет: [1, 4, 9, 16, 25]

// Сохранение контекста this
const counter = {
	count: 0,
	increment: function() {
		setInterval(() => {
		console.log(++this.count);
		}, 1000);
	}
};

counter.increment(); // Будет выводить увеличивающееся число каждую секунду
```

#### When to use what?

- **Function Declaration (Объявление функции)**: Когда нужна функция, доступная во всей области видимости, или когда требуется создать конструктор.
- **Function Expression (Функциональное выражение)**: Когда нужно создать функцию и сразу присвоить её переменной или передать как аргумент.
- **Arrow Function (Стрелочная функция)**: Для коротких функций, особенно колбэков, и когда важно сохранить контекст `this` окружающей области.

## Functional Scope

### Global Scope vs. Functional Scope

- Область видимости в JavaScript определяет, где переменные и функции могут быть доступны и использованы в коде. В JavaScript есть два основных типа области видимости:

  - **Global Scope (Глобальная область видимости):** Переменные и функции, объявленные в глобальной области видимости, доступны в любом месте вашего скрипта. Глобальная область видимости создается, когда переменные объявляются вне каких-либо функций или блоков кода. Однако чрезмерное использование глобальных переменных может привести к конфликтам имен и затруднить отладку кода.
  - **Functional Scope (Функциональная область видимости ):** Переменные, объявленные внутри функции, доступны только в пределах этой функции и недоступны вне её. Эта область видимости защищает данные от случайного изменения или доступа из других частей кода.

**Samples:**

```javascript
var globalVar = "I'm global"

function exampleFunction() {
  var localVar = "I'm local"
  console.log(globalVar) // "I'm global"
  console.log(localVar) // "I'm local"
}

exampleFunction()
console.log(globalVar) // "I'm global"
console.log(localVar) // ReferenceError: localVar is not defined
```

### Variable Visibility Areas

Область видимости переменных определяется тем, где они объявлены, и ограничивает доступ к ним из других частей кода. Переменные, объявленные в одной области видимости, недоступны в другой, если она не является вложенной. Это предотвращает случайное изменение переменных и защищает данные.

**Samples:**

```javascript
function outer() {
  var a = 1
  function inner() {
    var b = 2
    console.log(a) // 1 (доступна из внешней функции)
    console.log(b) // 2 (локальная переменная)
  }
  inner()
  console.log(a) // 1 (локальная переменная)
  console.log(b) // ReferenceError: b is not defined
}
outer()
```

В этом примере переменная `b` доступна только внутри функции `inner`, а переменная `a` доступна как внутри функции `inner`, так и в `outer`. Это пример замкнутости областей видимости.

### Working with Nested Scopes

Вложенные области видимости — это концепция, где функции имеют доступ к переменным из областей видимости, в которых они были объявлены, и всех внешних областей видимости. Это позволяет внутренним функциям использовать данные из внешних функций, но внешние функции не могут получить доступ к переменным внутренних функций.

**Samples:**

```javascript
function outerMost() {
  var a = 1
  function outer() {
    var b = 2
    function inner() {
      var c = 3
      console.log(a, b, c) // 1 2 3
    }
    inner()
    console.log(a, b) // 1 2
    console.log(c) // ReferenceError: c is not defined
  }
  outer()
  console.log(a) // 1
  console.log(b) // ReferenceError: b is not defined
}
outerMost()
```

Здесь `inner` имеет доступ к `a` и `b` из внешних областей видимости, но `outerMost` не может получить доступ к `b` и `c`, потому что они объявлены в более узких областях видимости. Это поведение обеспечивает модульность и изоляцию данных.

## Closures Advanced

### Understanding Context and Lexical Environments

В JavaScript глубокое понимание лексического окружения (lexical environment) и контекста выполнения (execution context) — ключ к освоению замыканий, работе с функциями высшего порядка и построению сложных архитектур.

#### Lexical Environments

**Лексическое окружение** — это внутренняя структура, которую JavaScript создает для отслеживания всех переменных и функций, доступных в определенной области видимости. Каждый раз, когда интерпретатор встречает новую функцию или блок кода (например, тело функции, блок `if`, `for`, `let`/`const`), он создает новое лексическое окружение.

**Структура лексического окружения:**

- **Environment Record** — объект, в котором хранятся все локальные переменные, параметры функции и объявления функций.
- **Ссылка на внешнее лексическое окружение** — указатель на родительское окружение, позволяющий искать переменные выше по цепочке областей видимости.

**Как это работает:**

- Когда вы обращаетесь к переменной, JavaScript сначала ищет её в текущем лексическом окружении.
- Если переменная не найдена, поиск продолжается во внешнем окружении, и так далее, пока не будет достигнуто глобальное окружение.
- Эта цепочка называется **scope chain** (цепочка областей видимости).

**Samples:**

```javascript
function outer() {
  let a = 10
  function inner() {
    let b = 20
    console.log(a + b) // a найден во внешнем окружении
  }
  inner()
}
outer()
```

В этом примере функция `inner` имеет доступ к переменной `a` из внешнего лексического окружения функции `outer`.

#### Execution Context

**Контекст выполнения** — это абстракция, описывающая, как JavaScript "видит" выполнение кода в определенный момент времени. Каждый раз, когда вызывается функция (или начинается выполнение скрипта), создается новый execution context.

**Execution context включает:**

- Лексическое окружение (scope chain)
- Значение `this` (контекст вызова)
- Переменные, параметры, функции, объявленные в текущей области видимости
- Другие внутренние служебные данные

**Типы execution context:**

1. **Глобальный контекст** — создается при запуске скрипта, существует всегда.
2. **Функциональный контекст** — создается при каждом вызове функции.
3. **Контекст eval** — создается при выполнении кода через `eval()` (используется редко).

**Значение `this`:**

- В глобальном контексте (не в строгом режиме) `this` ссылается на глобальный объект (`window` в браузере).
- В методах объекта — на сам объект.
- В функциях-конструкторах — на создаваемый экземпляр.
- В стрелочных функциях — наследуется из внешнего контекста.

**Samples:**

```javascript
const obj = {
  value: 42,
  show: function () {
    console.log(this.value) // this указывает на obj
  },
}
obj.show() // 42
```

### Closures

**Замыкание** — это функция, которая "запоминает" свое лексическое окружение даже после того, как внешняя функция завершила выполнение. Благодаря этому внутренние функции могут продолжать доступ к переменным из внешней функции.

**Как работают замыкания:**

- Когда функция возвращает другую функцию или передает её куда-то, внутренняя функция сохраняет ссылку на лексическое окружение, в котором была создана.
- Это позволяет реализовать приватные переменные, инкапсуляцию и создавать фабрики функций.

**Samples:**

```javascript
function makeCounter() {
  let count = 0
  return function () {
    count++
    return count
  }
}

const counter1 = makeCounter()
console.log(counter1()) // 1
console.log(counter1()) // 2

const counter2 = makeCounter()
console.log(counter2()) // 1 (независимый счетчик)
```

Здесь каждая функция-счетчик имеет собственное лексическое окружение с переменной `count`.

**Преимущества замыканий:**

1. **Инкапсуляция данных:** Можно создавать приватные переменные, недоступные извне.
2. **Сохранение состояния:** Замыкания позволяют "помнить" значения между вызовами функции.
3. **Фабрики функций:** Можно создавать функции с предустановленными параметрами (частичное применение, каррирование).

**Samples factory functions:**

```javascript
function multiplyBy(factor) {
  return function (number) {
    return number * factor
  }
}

const double = multiplyBy(2)
const triple = multiplyBy(3)

console.log(double(5)) // 10
console.log(triple(5)) // 15
```

Здесь `double` и `triple` — это замыкания, каждое из которых "помнит" свой `factor`.

**Важные замечания:**

- Замыкания могут приводить к утечкам памяти, если неаккуратно хранить большие объекты в лексическом окружении.
- В современных браузерах сборщик мусора умеет очищать неиспользуемые замыкания, но лучше избегать избыточных ссылок.

#### Практические применения замыканий

1. **Приватные методы и переменные:**

   ```javascript
   function SecretHolder(secret) {
     return {
       getSecret: function () {
         return secret
       },
       setSecret: function (newSecret) {
         secret = newSecret
       },
     }
   }
   const holder = SecretHolder('hidden')
   console.log(holder.getSecret()) // 'hidden'
   holder.setSecret('new')
   console.log(holder.getSecret()) // 'new'
   ```

2. **Модули:**
   Замыкания лежат в основе паттерна "модуль", позволяя создавать изолированные области видимости.

3. **Асинхронные операции:**
   Замыкания позволяют "запоминать" переменные в колбэках, промисах, обработчиках событий.

**Summary:**  
Лексическое окружение и контекст выполнения — фундаментальные понятия, которые определяют, как JavaScript ищет переменные и как работает `this`. Замыкания — мощный инструмент для управления состоянием, инкапсуляции и построения сложных архитектур. Глубокое понимание этих концепций отличает опытного JavaScript-разработчика.

### Differences between Scope and Context

В JavaScript часто путают понятия **область видимости** (scope) и **контекст выполнения** (context), хотя это два совершенно разных механизма, определяющих, как интерпретатор работает с переменными и значением `this`.

#### Scope

**Область видимости** — это механизм, который определяет, где в коде доступны переменные, функции и параметры. Она отвечает на вопрос: "Где я могу обратиться к этой переменной по имени?"

**Виды областей видимости:**

1. **Global Scope:**

   - Переменные, объявленные вне всех функций и блоков, доступны в любом месте скрипта.
   - Пример:
     ```javascript
     let globalVar = 10
     function foo() {
       console.log(globalVar) // 10
     }
     foo()
     ```

2. **Function Scope:**

   - Переменные, объявленные с помощью `var` внутри функции, доступны только внутри этой функции.
   - Пример:
     ```javascript
     function bar() {
       var localVar = 5
       console.log(localVar) // 5
     }
     // console.log(localVar); // ReferenceError
     ```

3. **Block Scope:**
   - С появлением `let` и `const` (ES6) переменные могут быть ограничены блоком `{ ... }`.
   - Пример:
     ```javascript
     if (true) {
       let blockVar = 20
       console.log(blockVar) // 20
     }
     // console.log(blockVar); // ReferenceError
     ```

**Особенности:**

- Область видимости формируется на этапе написания кода (лексически), а не во время выполнения.
- Вложенные функции имеют доступ к переменным внешних областей видимости (scope chain).
- Переменные с одинаковым именем в разных областях видимости не конфликтуют между собой.

**Samples nested scope:**

```javascript
let a = 1
function outer() {
  let b = 2
  function inner() {
    let c = 3
    console.log(a, b, c) // 1 2 3
  }
  inner()
}
outer()
```

#### Context

**Контекст выполнения** — это динамическая информация о том, какой объект в данный момент времени является значением ключевого слова `this`. Контекст зависит не от того, где функция объявлена, а от того, как она вызвана.

**Ключевые моменты:**

- Контекст всегда связан с вызовом функции.
- Значение `this` может меняться в зависимости от способа вызова.

**Основные типы контекста:**

1. **Глобальный контекст:**

   - Вне каких-либо функций, `this` ссылается на глобальный объект (`window` в браузере, `global` в Node.js).
   - Пример:
     ```javascript
     console.log(this) // window (в браузере)
     ```

2. **Контекст объекта (метода):**

   - Если функция вызвана как метод объекта, `this` указывает на этот объект.
   - Пример:
     ```javascript
     const user = {
       name: 'Bob',
       sayHi: function () {
         console.log(this.name)
       },
     }
     user.sayHi() // 'Bob'
     ```

3. **Потеря контекста:**

   - Если метод присваивается переменной и вызывается как обычная функция, контекст теряется.
   - Пример:
     ```javascript
     const greet = user.sayHi
     greet() // undefined (или ошибка в строгом режиме)
     ```

4. **Явное задание контекста:**

   - С помощью методов `call`, `apply`, `bind` можно явно указать, чему должно быть равно `this`.
   - Пример:
     ```javascript
     function show() {
       console.log(this)
     }
     show.call({a: 1}) // {a: 1}
     ```

5. **Стрелочные функции:**
   - Не имеют собственного `this`, а наследуют его из внешнего лексического окружения.
   - Пример:
     ```javascript
     const obj = {
       value: 42,
       show: () => console.log(this.value),
     }
     obj.show() // undefined (this — глобальный)
     ```

**Samples:**

```javascript
const person = {
  name: 'Alice',
  greet: function () {
    console.log(`Hello, my name is ${this.name}`)
  },
}

person.greet() // "Hello, my name is Alice"
const greetFunction = person.greet
greetFunction() // "Hello, my name is undefined" (или ошибка в строгом режиме)
```

**Здесь:**

- Переменная `name` находится в области видимости объекта `person`.
- Вызов `person.greet()` — контекст `this` указывает на объект `person`.
- Вызов `greetFunction()` — контекст теряется, `this` становится глобальным объектом или `undefined` (в строгом режиме).

#### Краткое сравнение

| Параметр        | Scope (Область видимости)         | Context (Контекст выполнения)      |
| --------------- | --------------------------------- | ---------------------------------- |
| Что определяет? | Где доступны переменные           | Какой объект — значение `this`     |
| Когда задаётся? | На этапе написания кода (лексика) | Во время вызова функции (динамика) |
| Как меняется?   | Вложенность функций/блоков        | Способ вызова функции              |

**Summary:**

- **Scope** — это про доступ к переменным и функции, определяется структурой кода.
- **Context** — это про то, на какой объект ссылается `this` в момент вызова функции.

## The Mechanism of Lexical Environment Traversal

В JavaScript поиск переменных всегда происходит по цепочке лексических окружений — это фундаментальный механизм, лежащий в основе работы областей видимости и замыканий.

Когда интерпретатор встречает обращение к переменной внутри функции, он действует по следующему алгоритму:

1. **Поиск в текущем лексическом окружении:**  
   Сначала JavaScript ищет переменную среди локальных переменных текущей функции или блока.
2. **Переход к внешнему окружению:**  
   Если переменная не найдена, поиск продолжается во внешнем (родительском) лексическом окружении, в котором была объявлена функция.
3. **Движение вверх по цепочке:**  
   Этот процесс повторяется рекурсивно, пока не будет достигнуто глобальное окружение.
4. **Глобальное окружение:**  
   Если переменная не найдена нигде в цепочке, возникает ошибка ReferenceError.

**Этот процесс называется лексическим поиском (lexical lookup) или traversal of the scope chain.**

**Samples:**

```javascript
let a = 'global'

function outer() {
  let b = 'outer'
  function middle() {
    let c = 'middle'
    function inner() {
      let d = 'inner'
      console.log(a, b, c, d)
    }
    inner()
  }
  middle()
}

outer() // Выведет: "global outer middle inner"
```

**Пошаговый разбор:**

- Внутри функции `inner` переменная `d` находится сразу (локальная).
- Переменная `c` ищется во внешнем окружении функции `middle`.
- Переменная `b` ищется еще выше — в окружении функции `outer`.
- Переменная `a` находится в самом верхнем уровне — глобальном окружении.

**Практическое значение:**

- Такой механизм позволяет внутренним функциям иметь доступ к переменным всех внешних функций, в которых они были объявлены.
- Это основа для работы замыканий, фабричных функций и многих паттернов JavaScript.

## Connection between Function and its Lexical Environment

Каждая функция в JavaScript "помнит" то лексическое окружение, в котором она была создана, даже если она будет вызвана вне этого окружения. Это ключевая особенность, которая делает возможными замыкания.

**Что это значит на практике?**

- Когда функция возвращается из другой функции или передается как аргумент, она сохраняет доступ ко всем переменным, которые были доступны в момент её создания.
- Даже если внешняя функция уже завершила выполнение, внутренние функции продолжают "видеть" переменные из её окружения.

**Samples:**

```javascript
function makeAdder(x) {
  return function (y) {
    return x + y
  }
}

const add5 = makeAdder(5)
const add10 = makeAdder(10)

console.log(add5(3)) // 8
console.log(add10(3)) // 13
```

**Разбор:**

- При вызове `makeAdder(5)` создается новая функция, которая замыкает в себе значение `x = 5`.
- Аналогично, `makeAdder(10)` создает функцию с собственным замкнутым значением `x = 10`.
- Даже после завершения работы `makeAdder`, возвращенные функции продолжают иметь доступ к своим значениям `x`.

**Почему это важно?**

- Это позволяет создавать функции с "памятью" — они могут хранить состояние между вызовами.
- Такой механизм лежит в основе приватных переменных, фабричных функций, обработчиков событий и многих других паттернов.

**Важное замечание:**  
Если функция не находит переменную в своем лексическом окружении, она всегда будет искать её выше по цепочке, но никогда не будет искать в окружении, в котором она была вызвана (только в том, где была объявлена!).

**Summary:**

- Механизм обхода лексических окружений обеспечивает надежную и предсказуемую работу областей видимости.
- Связь функции с её лексическим окружением — основа для замыканий и многих продвинутых возможностей JavaScript.

## Advanced Functions

### `this` in Functions

В JavaScript ключевое слово `this` — это динамическая ссылка на объект, который "владеет" текущим контекстом выполнения функции. Понимание того, как работает `this`, критически важно для написания корректного и предсказуемого кода, особенно при работе с объектами, классами, обработчиками событий и асинхронными функциями.

#### Основные правила определения `this`

1. **Global context:**
   - Вне каких-либо функций или внутри обычной функции, вызванной без объекта, `this` указывает на глобальный объект (`window` в браузере, `global` в Node.js).
   - В строгом режиме (`'use strict'`) — `this` будет `undefined`.
   - Пример:
     ```javascript
     function show() {
       console.log(this);
     }
     show(); // window (или undefined в строгом режиме)
     ```

2. **Object method:**
   - Если функция вызвана как метод объекта (через точку), `this` указывает на этот объект.
   - Пример:
     ```javascript
     const user = {
       name: 'Alice',
       sayHi() {
         console.log(this.name);
       }
     };
     user.sayHi(); // 'Alice'
     ```

3. **Constructor:**
   - При вызове функции с помощью `new`, внутри функции создается новый объект, и `this` указывает на этот объект.
   - Пример:
     ```javascript
     function Person(name) {
       this.name = name;
     }
     const bob = new Person('Bob');
     console.log(bob.name); // 'Bob'
     ```

4. **Explicit binding:**
   - Методы `call()`, `apply()`, `bind()` позволяют явно указать, чему должно быть равно `this` при вызове функции.
   - Пример:
     ```javascript
     function greet() {
       console.log(this);
     }
     greet.call({ custom: 'object' }); // { custom: 'object' }
     ```

5. **Arrow functions:**
   - Стрелочные функции не имеют собственного `this`. Они наследуют значение `this` из внешнего лексического окружения, в котором были объявлены.
   - Пример:
     ```javascript
     const obj = {
       value: 42,
       show: () => console.log(this.value)
     };
     obj.show(); // undefined (this — глобальный)
     ```

#### Reference Type & Losing `this`

**Потеря контекста** — одна из самых частых ошибок при работе с методами объектов. Если метод объекта передать как callback или сохранить в переменную, он теряет свой контекст, и `this` становится либо глобальным объектом, либо `undefined` (в строгом режиме).

**Пример:**
```javascript
const obj = {
  name: 'Test',
  show() {
    console.log(this.name);
  }
};

setTimeout(obj.show, 1000); // undefined (контекст потерян)
```

**Способы решения:**

1. **Использование `bind`:**
   - Привязывает функцию к определенному объекту, возвращая новую функцию с фиксированным `this`.
   ```javascript
   setTimeout(obj.show.bind(obj), 1000); // 'Test'
   ```

2. **Стрелочные функции:**
   - Используйте стрелочную функцию-обертку, чтобы сохранить контекст.
   ```javascript
   setTimeout(() => obj.show(), 1000); // 'Test'
   ```

3. **Сохранение `this` в переменную:**
   - Старый подход, когда внутри функции сохраняют ссылку на `this` в переменную (`self` или `that`).
   ```javascript
   const self = this;
   setTimeout(function() {
     self.show();
   }, 1000);
   ```

#### Understand the Difference between Function and Method

- **Функция** — это самостоятельный блок кода, который может быть вызван независимо и не обязательно связан с каким-либо объектом.
- **Метод** — это функция, являющаяся свойством объекта. При вызове метода через объект (`obj.method()`), `this` внутри метода указывает на этот объект.

**Пример:**
```javascript
function standalone() {
  console.log(this);
}

const obj = {
  method: function() {
    console.log(this);
  }
};

standalone(); // window (или undefined в строгом режиме)
obj.method(); // obj
```

**Важно:**  
Если метод объекта присваивается переменной и вызывается как обычная функция, он теряет свой контекст.

#### Manage `this`

JavaScript предоставляет три метода для явного управления значением `this`:

1. **`call(thisArg, arg1, arg2, ...)`**
   - Вызывает функцию с указанным `this` и отдельными аргументами.
   - Пример:
     ```javascript
     function greet(greeting, punctuation) {
       console.log(`${greeting}, ${this.name}${punctuation}`);
     }
     const person = { name: "Alice" };
     greet.call(person, "Hello", "!"); // "Hello, Alice!"
     ```

2. **`apply(thisArg, [argsArray])`**
   - То же, что и `call`, но аргументы передаются массивом.
   - Пример:
     ```javascript
     greet.apply(person, ["Hi", "."]); // "Hi, Alice."
     ```

3. **`bind(thisArg, arg1, arg2, ...)`**
   - Возвращает новую функцию с привязанным `this` и, опционально, начальными аргументами.
   - Пример:
     ```javascript
     const boundGreet = greet.bind(person, "Welcome");
     boundGreet("!!"); // "Welcome, Alice!!"
     ```

**Особенности:**
- `bind` не вызывает функцию сразу, а возвращает новую функцию.
- `call` и `apply` вызывают функцию немедленно.

#### Типичные ошибки и лучшие практики

- **Не используйте стрелочные функции как методы объекта**, если вам нужен доступ к `this` — они всегда берут `this` из внешнего контекста.
- **Избегайте передачи методов объектов как callback без привязки контекста** — используйте `bind` или стрелочные функции.
- **В классах (ES6+) методы по умолчанию не привязаны к экземпляру** — используйте стрелочные свойства или привязывайте методы в конструкторе.

**Пример с классом:**
```javascript
class Counter {
  constructor() {
    this.count = 0;
    this.inc = this.inc.bind(this); // Привязка метода
  }
  inc() {
    this.count++;
    console.log(this.count);
  }
}
const c = new Counter();
setTimeout(c.inc, 1000); // 1
```
**Summary:**  
Понимание механизма работы `this` — основа для грамотной работы с объектами, классами и функциями в JavaScript. Всегда обращайте внимание на то, как вызывается функция, и используйте современные подходы для управления контекстом, чтобы избежать неожиданных ошибок.


### Binding, Binding One Function Twice

Важно отметить, что однажды привязанная функция не может быть перепривязана. Последующие вызовы `bind()` не изменят изначально установленное значение `this`.

**Samples:**

```javascript
const obj1 = {name: 'obj1'}
const obj2 = {name: 'obj2'}

function showName() {
  console.log(this.name)
}

const bound = showName.bind(obj1)
bound() // "obj1"

const attemptRebind = bound.bind(obj2)
attemptRebind() // Все еще "obj1"
```

## ECMAScript Intermediate

### Function Default Parameters

Параметры функции по умолчанию - возможность, введенная в ECMAScript 6 (ES6), которая позволяет задавать значения параметров, используемые в случае, если аргументы не были переданы или были переданы как `undefined`.

1. **Syntax (Синтаксис)**: Значения по умолчанию задаются с помощью оператора присваивания (`=`) в списке параметров функции.
2. **Activation (Активация)**: Значение по умолчанию используется, когда аргумент не передан или передан как `undefined`.
3. **Variable expressions (Выражения переменных)**: В качестве значений по умолчанию можно использовать не только примитивы, но и выражения, включая вызовы функций.
4. **Access to previous parameters (Доступ к предыдущим параметрам)**: Параметры по умолчанию могут ссылаться на ранее объявленные параметры в том же списке параметров.

```javascript

function greet(name = 'Guest', time = new Date().getHours()) {
	let greeting = time < 12 ? 'Good morning' : 'Good day';
	console.log(${greeting}, ${name}!);
}

greet(); // Выведет "Good day, Guest!" (если сейчас после полудня)
greet('Alice'); // Выведет "Good day, Alice!" (если сейчас после полудня)


function getDefaultName() {
	return 'Anonymous';
}

function welcome(name = getDefaultName()) {
	console.log(Welcome, ${name}!);
}

welcome(); // "Welcome, Anonymous!"
welcome(undefined); // "Welcome, Anonymous!"
welcome(null); // "Welcome, null!"

function createUser(name = 'User', id = name.toLowerCase() + Math.random().toString().slice(2, 10)) {
	return { name, id }
}

console.log(createUser()); // { name: "User", id: "user84175301" }
console.log(createUser('Alice')); // { name: "Alice", id: "alice17539813" }
```

#### Important notes:

- Параметры по умолчанию вычисляются в момент вызова функции, а не в момент её определения.
- Если передан `null`, он не активирует значение по умолчанию, так как `null` считается валидным значением.
- Параметры по умолчанию могут привести к неожиданному поведению при использовании с деструктуризацией объектов.

### Using Spread Operator for Function Arguments

Оператор расширения (spread operator) `...` — это мощный синтаксический инструмент, появившийся в ES6, который позволяет "раскрывать" элементы итерируемых объектов (массивов, строк, Set, Map и др.) в местах, где ожидается список значений или элементов.

#### Основные возможности spread-оператора

1. **Передача элементов массива как отдельных аргументов функции**

   Вместо передачи массива целиком, можно "развернуть" его элементы:
   ```javascript
   const numbers = [5, 2, 8, 1, 9];
   console.log(Math.max(...numbers)); // 9
   ```

2. **Объединение и копирование массивов**

   Spread позволяет легко создавать новые массивы на основе существующих:
   ```javascript
   const arr1 = [1, 2, 3];
   const arr2 = [4, 5];
   const combined = [...arr1, ...arr2]; // [1, 2, 3, 4, 5]
   const copy = [...arr1]; // [1, 2, 3]
   ```

3. **Работа с итерируемыми объектами**

   Можно использовать spread для преобразования строк, Set, Map в массив:
   ```javascript
   console.log([...new Set([1, 2, 2, 3])]); // [1, 2, 3]
   console.log([...'Hello']); // ['H', 'e', 'l', 'l', 'o']
   ```

4. **Spread для объектов (ES2018+)**

   Позволяет копировать и объединять объекты:
   ```javascript
   const obj1 = { a: 1, b: 2 };
   const obj2 = { b: 3, c: 4 };
   const merged = { ...obj1, ...obj2 }; // { a: 1, b: 3, c: 4 }
   ```

5. **Передача аргументов в функции с переменным числом параметров**

   ```javascript
   function process(x, y, ...rest) {
     console.log(x, y, rest);
   }
   process(1, 2, ...numbers); // 1 2 [5, 2, 8, 1, 9]
   ```

#### Важные замечания

- Spread-оператор всегда создает **поверхностную копию** (shallow copy). Если элементы массива или свойства объекта — это объекты, копируются только ссылки на них.
- При объединении объектов свойства с одинаковыми ключами перезаписываются последними.
- Использование spread с очень большими массивами или объектами может быть менее эффективно по памяти и производительности, чем специализированные методы.

### Comparing `arguments` and Rest Parameters

В JavaScript есть два способа работать с функциями, принимающими переменное количество аргументов: устаревший объект `arguments` и современный синтаксис rest-параметров (`...args`). Они похожи по назначению, но имеют принципиальные различия.

#### Объект `arguments`

- **Что это:** Специальный массивоподобный объект, доступный внутри всех обычных функций (но не стрелочных).
- **Особенности:**
  - Не является настоящим массивом (нет методов `map`, `filter` и т.д.).
  - Содержит все переданные аргументы, даже если их больше, чем объявлено в параметрах.
  - Не работает в стрелочных функциях.
- **Пример:**
  ```javascript
  function sumOld() {
    let total = 0;
    for (let i = 0; i < arguments.length; i++) {
      total += arguments[i];
    }
    return total;
  }
  console.log(sumOld(1, 2, 3, 4)); // 10
  ```

#### Rest-параметры (`...args`)

- **Что это:** Современный синтаксис, позволяющий собирать "остаточные" аргументы в настоящий массив.
- **Особенности:**
  - Работает только если явно объявлен в параметрах функции.
  - Всегда возвращает массив, даже если не передано ни одного аргумента.
  - Может использоваться только как последний параметр в списке.
  - Работает и в обычных, и в стрелочных функциях.
- **Пример:**
  ```javascript
  function sumNew(...numbers) {
    return numbers.reduce((sum, num) => sum + num, 0);
  }
  console.log(sumNew(1, 2, 3, 4)); // 10
  ```

#### Сравнение и лучшие практики

| Характеристика         | `arguments`           | Rest-параметры (`...args`) |
|----------------------- |----------------------|---------------------------|
| Тип                    | Массивоподобный объект | Настоящий массив          |
| Методы массива         | Нет                  | Да                        |
| Стрелочные функции     | Нет                  | Да                        |
| Явное объявление       | Не требуется         | Требуется                 |
| Современность          | Устаревший           | Рекомендуется             |

**Samples:**
```javascript
function processItems(first, second, ...rest) {
  console.log('First:', first);
  console.log('Second:', second);
  console.log('Rest:', rest);
}
processItems('a', 'b', 'c', 'd', 'e');
// First: a
// Second: b
// Rest: ["c", "d", "e"]

// Деструктуризация с rest-параметром
function analyzeArray([first, second, ...rest]) {
  console.log('First element:', first);
  console.log('Second element:', second);
  console.log('Remaining elements:', rest);
}
analyzeArray([1, 2, 3, 4, 5]);
// First element: 1
// Second element: 2
// Remaining elements: [3, 4, 5]
```

#### Практические рекомендации

- Используйте rest-параметры (`...args`) вместо `arguments` в современном коде — это делает функции более читаемыми и безопасными.
- Если нужно работать с массивом аргументов, всегда предпочитайте rest-параметры, чтобы избежать ошибок и повысить совместимость с современными инструментами.
- Помните, что `arguments` не работает в стрелочных функциях.


**Summary:**  
Spread-оператор и rest-параметры — современные инструменты для работы с коллекциями и аргументами функций, делающие код чище, короче и безопаснее. Используйте их вместо устаревших подходов для написания современного и поддерживаемого JavaScript-кода.

## Array Concatenation with Spread Operator

Оператор расширения (`spread`, `...`) предоставляет современный, лаконичный и читаемый способ объединения массивов, который во многих случаях предпочтительнее классического метода `concat()`.

#### Основные преимущества spread-оператора для массивов

1. **Простой синтаксис:**  
   Используйте `...` перед каждым массивом внутри литерала нового массива, чтобы объединить их элементы.
   ```javascript
   const arr1 = [1, 2, 3];
   const arr2 = [4, 5, 6];
   const combined = [...arr1, ...arr2];
   console.log(combined); // [1, 2, 3, 4, 5, 6]
   ```

2. **Гибкость:**  
   Можно легко добавлять отдельные элементы между массивами или в начало/конец нового массива.
   ```javascript
   const withExtra = [...arr1, 'extra', ...arr2];
   console.log(withExtra); // [1, 2, 3, "extra", 4, 5, 6]
   ```

3. **Создание копий:**  
   Spread позволяет быстро создать поверхностную копию массива, не изменяя исходный.
   ```javascript
   const extended = [...arr1, 7, 8, 9];
   console.log(extended); // [1, 2, 3, 7, 8, 9]
   console.log(arr1); // [1, 2, 3] (оригинал не изменен)
   ```

4. **Работа с массивами объектов:**  
   Можно объединять массивы объектов, например, при работе с данными пользователей.
   ```javascript
   const users1 = [
     {id: 1, name: 'John'},
     {id: 2, name: 'Jane'},
   ];
   const users2 = [{id: 3, name: 'Bob'}];
   const allUsers = [...users1, ...users2];
   console.log(allUsers);
   // [{ id: 1, name: 'John' }, { id: 2, name: 'Jane' }, { id: 3, name: 'Bob' }]
   ```

#### Важные замечания

- **Поверхностная копия:** Spread-оператор копирует только верхний уровень массива. Если элементы — объекты или вложенные массивы, копируются только ссылки на них.
- **Производительность:** Для очень больших массивов spread может быть менее эффективен, чем `concat()` или циклы, из-за особенностей реализации в движке JavaScript.
- **Гибкость:** Spread можно использовать с любыми итерируемыми объектами, не только с массивами (например, со строками, Set, Map).

## Destructuring Assignments for Variables and Function Arguments

**Деструктуризация** — это современный синтаксис, позволяющий "распаковывать" значения из массивов и свойства из объектов в отдельные переменные. Это делает код более лаконичным, выразительным и удобным для чтения.

### Object Destructuring

Позволяет извлекать значения свойств объекта в переменные с теми же именами:
```javascript
const library = {
  name: "Центральная городская библиотека",
  books: [
    { title: "1984", author: "Джордж Оруэлл", year: 1949 },
    { title: "Гарри Поттер и философский камень", author: "Дж. К. Роулинг", year: 1997 },
    { title: "Убить пересмешника", author: "Харпер Ли", year: 1960 }
  ],
  staff: ["Анна", "Иван", "Мария"],
  location: {
    city: "Москва",
    street: "Арбат",
    building: "20",
  },
};

const { name, books } = library;
console.log(`Название библиотеки: ${name}`); // Центральная городская библиотека
```

### Array Destructuring

Позволяет извлекать элементы массива по позициям:
```javascript
const [firstBook, secondBook] = books;
console.log(`Первая книга: ${firstBook.title}`); // 1984
```

### Destructuring in function parameters

Можно сразу "распаковать" нужные свойства объекта-аргумента:
```javascript
function printBookInfo({ title, author, year }) {
  console.log(`"${title}" написана ${author} в ${year} году.`);
}
printBookInfo(secondBook); // "Гарри Поттер и философский камень" написана Дж. К. Роулинг в 1997 году.
```

### Nested and combined destructuring

Можно извлекать значения из вложенных структур:
```javascript
const { staff: [headLibrarian, ...otherStaff], location: { city, street } } = library;
console.log(`Главный библиотекарь: ${headLibrarian}`); // Анна
console.log(`Остальной персонал: ${otherStaff.join(", ")}`); // Иван, Мария
console.log(`Адрес: ${street}, ${city}`); // Арбат, Москва
```

### Destructuring with renaming and default values

```javascript
function getLibraryStats({
  name: libraryName,
  books: bookCollection,
  yearFounded = "Неизвестно"
}) {
  console.log(`Статистика для ${libraryName}:`);
  console.log(`Количество книг: ${bookCollection.length}`);
  console.log(`Год основания: ${yearFounded}`);
}
getLibraryStats(library);
```

### Destructuring in a loop

Очень удобно для перебора массивов объектов:
```javascript
for (const { title, author } of books) {
  console.log(`${author} - "${title}"`);
}
// Джордж Оруэлл - "1984"
// Дж. К. Роулинг - "Гарри Поттер и философский камень"
// Харпер Ли - "Убить пересмешника"
```

#### Важные замечания

- Для примитивных типов деструктуризация создает копии значений.
- Для объектов и массивов копируются только ссылки.
- Имена переменных при деструктуризации объектов должны совпадать с именами свойств, если не указано иное.
- Вложенная деструктуризация позволяет работать с любыми уровнями вложенности, но не стоит злоупотреблять — это может ухудшить читаемость кода.


### for...of loop (optional)

Цикл `for...of` — современный и удобный способ перебора элементов итерируемых объектов (массивов, строк, Set, Map и др.), появившийся в ES6.

#### Преимущества `for...of`:

- **Простота:** Не нужно управлять индексами или проверять длину массива.
- **Работает с любыми итерируемыми объектами:** Массивы, строки, коллекции Set/Map, генераторы.
- **Поддержка break/continue:** Можно прерывать цикл или переходить к следующей итерации.

#### Примеры использования

**Итерация по массиву:**
```javascript
const fruits = ['apple', 'banana', 'orange'];
for (const fruit of fruits) {
  console.log(fruit);
}
// apple
// banana
// orange
```

**Итерация по строке:**
```javascript
const str = 'Hello';
for (const char of str) {
  console.log(char);
}
// H
// e
// l
// l
// o
```

**Итерация по Set:**
```javascript
const uniqueNumbers = new Set([1, 2, 3, 2]);
for (const num of uniqueNumbers) {
  console.log(num);
}
// 1
// 2
// 3
```

#### Важные замечания

- `for...of` не работает напрямую с обычными объектами ({}), только с итерируемыми структурами.
- Если нужен доступ к индексу элемента массива, используйте `for...of` с `entries()`:
  ```javascript
  for (const [index, value] of fruits.entries()) {
    console.log(index, value);
  }
  // 0 'apple'
  // 1 'banana'
  // 2 'orange'
  ```
- Для перебора свойств объекта используйте `for...in` или методы `Object.keys()`, `Object.values()`, `Object.entries()`.

**Summary:**  
Spread-оператор, деструктуризация и цикл `for...of` — это современные инструменты, делающие работу с коллекциями в JavaScript более удобной, лаконичной и безопасной. Используйте их для написания чистого и эффективного кода!


## Objects Built-in Methods

### Utilizing Object.keys, Object.values и Object.entries

Встроенные методы `Object.keys()`, `Object.values()` и `Object.entries()` предоставляют удобные способы для перебора, фильтрации и трансформации объектов в JavaScript. Они особенно полезны при работе с коллекциями данных, когда нужно быстро получить список ключей, значений или пар ключ-значение.

#### Object.keys(obj)

- Возвращает массив строк, содержащих все **собственные** (не унаследованные) **перечисляемые** свойства объекта.
- Используется для перебора ключей объекта, фильтрации, подсчета количества свойств и т.д.

```javascript
const product = {
  name: 'Laptop',
  price: 1000,
  inStock: true,
  specs: {
    cpu: 'Intel i7',
    ram: '16GB',
    storage: '512GB SSD'
  }
};

const keys = Object.keys(product);
console.log(keys); // ['name', 'price', 'inStock', 'specs']

// Фильтрация только примитивных свойств
const primitiveKeys = keys.filter(key => typeof product[key] !== 'object');
console.log(primitiveKeys); // ['name', 'price', 'inStock']
```

#### Object.values(obj)

- Возвращает массив значений всех **собственных перечисляемых** свойств объекта.
- Удобно для подсчета, поиска, агрегации данных.

```javascript
const values = Object.values(product);
console.log(values); // ['Laptop', 1000, true, { cpu: 'Intel i7', ram: '16GB', storage: '512GB SSD' }]

// Подсчет числовых значений
const numericCount = values.filter(value => typeof value === 'number').length;
console.log(numericCount); // 1
```

#### Object.entries(obj)

- Возвращает массив пар `[ключ, значение]` для всех собственных перечисляемых свойств объекта.
- Особенно полезно для преобразования объекта в Map, для перебора с деструктуризацией, для сериализации.

```javascript
const entries = Object.entries(product);
console.log(entries);
// [['name', 'Laptop'], ['price', 1000], ['inStock', true], ['specs', {...}]]

// Пример: вывод характеристик товара
const allSpecs = Object.entries(product.specs)
  .map(([key, value]) => `${key}: ${value}`)
  .join(', ');
console.log(allSpecs); // "cpu: Intel i7, ram: 16GB, storage: 512GB SSD"
```

#### Комбинирование методов

Можно использовать эти методы вместе с методами массивов (`map`, `filter`, `reduce`) для сложных преобразований:

```javascript
// Преобразование ключей в верхний регистр
const upperCaseProduct = Object.keys(product).reduce((acc, key) => {
  acc[key.toUpperCase()] = product[key];
  return acc;
}, {});
console.log(upperCaseProduct);
// { NAME: 'Laptop', PRICE: 1000, INSTOCK: true, SPECS: {...} }
```

### Working with Static Object Methods

Статические методы объекта `Object` — это методы, вызываемые непосредственно на конструкторе `Object`, а не на экземплярах. Они предоставляют мощные инструменты для работы с объектами: клонирование, создание, заморозка, запечатывание, определение свойств и др.

#### Object.assign(target, ...sources)

- Копирует все **собственные перечисляемые** свойства из одного или нескольких исходных объектов в целевой объект.
- Возвращает изменённый целевой объект.
- **Внимание:** Копирование поверхностное (shallow copy).

```javascript
const target = { a: 1, b: 2 };
const source = { b: 3, c: 4 };
const result = Object.assign(target, source);

console.log(result); // { a: 1, b: 3, c: 4 }
console.log(target); // { a: 1, b: 3, c: 4 } (target изменён!)
```

**Совет:** Для создания нового объекта используйте пустой объект как первый аргумент:
```javascript
const merged = Object.assign({}, obj1, obj2);
```

#### Object.create(proto, [propertiesObject])

- Создаёт новый объект с указанным прототипом.
- Можно сразу определить свойства через второй аргумент.

```javascript
const personProto = {
  greet() {
    return `Hello, my name is ${this.name}`;
  }
};

const john = Object.create(personProto);
john.name = "John";
console.log(john.greet()); // "Hello, my name is John"
```

#### Object.freeze(obj)

- "Замораживает" объект: нельзя добавлять, удалять или изменять свойства.
- Все свойства становятся только для чтения и неконфигурируемыми.

```javascript
const obj = { prop: 42 };
Object.freeze(obj);

obj.prop = 33; // Изменение проигнорировано (или ошибка в строгом режиме)
console.log(obj.prop); // 42
```

#### Object.seal(obj)

- "Запечатывает" объект: нельзя добавлять или удалять свойства, но можно изменять существующие (если они не read-only).
- Свойства становятся неконфигурируемыми, но не обязательно только для чтения.

```javascript
const obj = { prop: 42 };
Object.seal(obj);

obj.newProp = 123; // Игнорируется
delete obj.prop;   // Игнорируется
obj.prop = 33;     // Можно изменить
console.log(obj);  // { prop: 33 }
```

#### Object.defineProperty(obj, prop, descriptor)

- Позволяет явно определить или изменить свойство объекта с заданными атрибутами (writable, enumerable, configurable).
- Используется для создания read-only, скрытых или вычисляемых свойств.

```javascript
const obj = {};

Object.defineProperty(obj, 'readOnly', {
  value: 42,
  writable: false, // нельзя изменить
  enumerable: true,
  configurable: false // нельзя удалить или перенастроить
});

obj.readOnly = 100; // Игнорируется
console.log(obj.readOnly); // 42
```

#### Практические советы и подводные камни

- **Поверхностное копирование:** Все методы копируют только верхний уровень объекта. Для глубокого клонирования используйте рекурсивные функции или сторонние библиотеки (`lodash.cloneDeep`).
- **Работа с прототипами:** `Object.create()` — мощный инструмент для создания объектов с нужным прототипом, но не забывайте про возможные проблемы с наследованием.
- **Иммутабельность:** Для неизменяемых структур используйте `Object.freeze()`, но помните, что вложенные объекты не замораживаются автоматически.
- **Оптимизация:** Методы `Object.keys/values/entries` не гарантируют порядок свойств для нечисловых ключей — не полагайтесь на порядок, если это критично.

**Summary:**  
Встроенные методы объекта — это фундаментальные инструменты для эффективной работы с данными в JavaScript. Используйте их для перебора, фильтрации, клонирования, защиты и трансформации объектов, чтобы писать чистый, современный и поддерживаемый код.

Вот более подробное, современное и структурированное описание для тем: флаги свойств и дескрипторы, а также создание итерируемых объектов с использованием Symbol.iterator. Я добавил больше объяснений, практических советов и акцентировал внимание на важных деталях.

### Property Flags and Descriptors

В JavaScript каждое свойство объекта обладает не только значением, но и набором специальных атрибутов — **флагов** (property flags), которые определяют поведение этого свойства. Эти флаги позволяют гибко управлять доступностью, видимостью и изменяемостью свойств, что особенно важно для инкапсуляции, безопасности и построения сложных API.

#### Основные флаги свойства

1. **`writable`**  
   Определяет, можно ли изменять значение свойства после его создания.
   - `true` — значение можно менять.
   - `false` — свойство становится только для чтения.

2. **`enumerable`**  
   Определяет, будет ли свойство отображаться при переборе объекта (например, в цикле `for...in` или при использовании `Object.keys()`).
   - `true` — свойство видно при перечислении.
   - `false` — свойство скрыто для перечисления.

3. **`configurable`**  
   Контролирует возможность удаления свойства и изменения его флагов (кроме `writable`).
   - `true` — свойство можно удалить или изменить его флаги.
   - `false` — свойство нельзя удалить, а его флаги нельзя изменить.

#### Работа с флагами через Object.defineProperty

Метод `Object.defineProperty(obj, prop, descriptor)` позволяет создавать или изменять свойства с заданными флагами. Это мощный инструмент для создания защищённых, скрытых или только для чтения свойств.

**Samples:**

```javascript
const obj = {};

// Создание свойства только для чтения, видимого при перечислении, не удаляемого
Object.defineProperty(obj, 'readOnly', {
  value: 42,
  writable: false,      // нельзя изменить значение
  enumerable: true,     // видно в циклах и Object.keys
  configurable: false   // нельзя удалить или перенастроить
});

obj.readOnly = 100;
console.log(obj.readOnly); // 42 (изменение проигнорировано)

delete obj.readOnly; // false (удаление не произойдет)
console.log('readOnly' in obj); // true

// Создание скрытого свойства
Object.defineProperty(obj, 'hidden', {
  value: 'secret',
  enumerable: false // не видно при перечислении
});

console.log(Object.keys(obj)); // ['readOnly'] — 'hidden' не отображается

// Получение дескриптора свойства
const desc = Object.getOwnPropertyDescriptor(obj, 'readOnly');
console.log(desc);
// { value: 42, writable: false, enumerable: true, configurable: false }
```

#### Практические советы

- Используйте флаги для создания приватных или защищённых свойств в библиотеках и классах.
- Свойства, созданные через `Object.defineProperty`, по умолчанию имеют все флаги `false`, если не указано иное.
- Для массового определения свойств используйте `Object.defineProperties()`.


### Creating Iterable Objects and Using Symbol.iterator (optional)

**Итерируемость** — это концепция, позволяющая объекту определять собственное поведение при переборе с помощью таких конструкций, как `for...of`, spread-оператор (`...`), деструктуризация и другие современные возможности JavaScript.

#### Как сделать объект итерируемым?

Для этого объект должен реализовать специальный метод с ключом `Symbol.iterator`. Этот метод должен возвращать **итератор** — объект с методом `next()`, который при каждом вызове возвращает объект вида `{ value, done }`:

- `value` — очередное значение последовательности
- `done` — булево, указывающее, завершена ли итерация

**Samples:**

```javascript
const customIterable = {
  data: ['A', 'B', 'C', 'D'],
  [Symbol.iterator]() {
    let index = 0;
    const arr = this.data;
    return {
      next() {
        if (index < arr.length) {
          return { value: arr[index++], done: false };
        } else {
          return { done: true };
        }
      }
    };
  }
};

// Использование в for...of
for (let item of customIterable) {
  console.log(item); // A, B, C, D
}

// Spread-оператор
console.log([...customIterable]); // ['A', 'B', 'C', 'D']

// Деструктуризация
const [first, second, ...rest] = customIterable;
console.log(first, second, rest); // A B ['C', 'D']
```

#### Практические применения

- Создание собственных коллекций и структур данных (например, двусвязные списки, деревья), которые можно перебирать стандартными средствами языка.
- Генерация последовательностей "на лету" (например, бесконечные генераторы, ленивые вычисления).
- Совместимость с современными API, использующими итерируемые объекты.

#### Важные замечания

- Любой объект, реализующий метод `[Symbol.iterator]`, считается итерируемым.
- Итераторы могут быть как простыми (как в примере выше), так и сложными (например, с поддержкой возврата и выбрасывания ошибок).
- Для создания сложных итерируемых последовательностей удобно использовать генераторы (`function*`).

**Пример генератора:**
```javascript
function* idGenerator() {
  let id = 1;
  while (true) {
    yield id++;
  }
}
const gen = idGenerator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
```

**Summary:**  
Флаги свойств и дескрипторы позволяют создавать гибкие и защищённые структуры данных, а итерируемость — интегрировать свои объекты в современные синтаксические конструкции JavaScript. Используйте эти возможности для написания более выразительного, безопасного и современного кода.

## Arrays Iterating, Sorting, Filtering

### Sorting and Custom Sorting Arrays

Метод `sort()` позволяет сортировать массивы на месте. По умолчанию элементы сортируются как строки, что может привести к неожиданным результатам при работе с числами.

- Для числовой сортировки всегда передавайте функцию сравнения:
  ```javascript
  const numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
  numbers.sort((a, b) => a - b); // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
  ```

- Для сортировки объектов по свойству:
  ```javascript
  const people = [
    { name: 'John', age: 30 },
    { name: 'Alice', age: 25 },
    { name: 'Bob', age: 35 },
  ];
  people.sort((a, b) => a.age - b.age);
  // [{name: 'Alice', ...}, {name: 'John', ...}, {name: 'Bob', ...}]
  ```

**Важно:**  
`sort()` изменяет исходный массив! Если нужно сохранить оригинал, скопируйте массив перед сортировкой.

### Filtering Array Elements

Метод `filter()` создает новый массив, включающий только те элементы, которые удовлетворяют условию, заданному в переданной функции.

- Оригинальный массив не изменяется.
- Удобно для создания подмножеств, поиска, удаления элементов по условию.

```javascript
const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const evenNumbers = numbers.filter(num => num % 2 === 0);
console.log(evenNumbers); // [2, 4, 6, 8, 10]

const people = [
  { name: 'John', age: 30 },
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 35 },
];
const adults = people.filter(person => person.age >= 30);
console.log(adults); // [{ name: 'John', age: 30 }, { name: 'Bob', age: 35 }]
```

**Summary:**  
Понимание разницы между методами копирования и модификации массивов, а также умение использовать методы сортировки, фильтрации и "выпрямления" вложенных структур — основа эффективной работы с данными в JavaScript. Используйте эти инструменты для написания чистого, предсказуемого и поддерживаемого кода.


## ECMAScript Data Types & Expressions

### Working with Object Computed Properties

**Вычисляемые свойства** (computed properties) — это синтаксис, позволяющий динамически формировать имена свойств объекта на этапе его создания или модификации. Это особенно полезно, когда имена свойств зависят от переменных, выражений или внешних данных.

#### Основные сценарии использования вычисляемых свойств

1. **Динамическое создание свойств на основе переменных**

   Вы можете использовать переменные или выражения в квадратных скобках при объявлении объекта:
   ```javascript
   const prefix = 'user';
   const id = 1234;

   const user = {
     [`${prefix}_${id}`]: 'John Doe',
   };

   console.log(user.user_1234); // 'John Doe'
   ```

2. **Использование выражений для имен свойств**

   Любое выражение внутри квадратных скобок будет вычислено и использовано как имя свойства:
   ```javascript
   const obj = {
     ['a' + 'b']: 1,
     [1 + 2]: 3,
   };

   console.log(obj.ab);    // 1
   console.log(obj['3']);  // 3
   ```

3. **Создание методов с динамическими именами**

   Можно определять методы с именами, зависящими от переменных:
   ```javascript
   const actions = {
     GET: 'getData',
     POST: 'postData',
   };
   const api = {
     [actions.GET]: function () {
       console.log('Getting data...');
     },
     [actions.POST]: function () {
       console.log('Posting data...');
     },
   };

   api.getData();  // 'Getting data...'
   api.postData(); // 'Posting data...'
   ```

4. **Использование Symbol как вычисляемого свойства**

   Символы позволяют создавать уникальные ключи, которые не конфликтуют с другими свойствами:
   ```javascript
   const uniqueKey = Symbol('description');

   const obj = {
     [uniqueKey]: 'This is a unique property',
   };

   console.log(obj[uniqueKey]); // 'This is a unique property'
   ```

**Преимущества:**
- Гибкость структуры объектов.
- Возможность интеграции с внешними API и динамическими данными.
- Уникальность ключей при использовании Symbol.

**Практические советы:**
- Используйте computed properties для генерации свойств на лету, например, при обработке форм, динамических конфигураций, построении API-ответов.
- Не злоупотребляйте вычисляемыми свойствами для статических структур — это может ухудшить читаемость кода.

### Iterating Through Object Keys

Перебор свойств объекта — одна из самых частых задач при работе с данными в JavaScript. Существует несколько способов и инструментов для этого, каждый из которых подходит для разных сценариев.

#### Современные методы перебора

1. **Object.entries()**

   Возвращает массив пар `[ключ, значение]` для всех **собственных перечисляемых** свойств объекта. Удобно для перебора с деструктуризацией:
   ```javascript
   const person = { name: 'Alice', age: 30, job: 'engineer' };

   Object.entries(person).forEach(([key, value]) => {
     console.log(`${key}: ${value}`);
   });
   // name: Alice
   // age: 30
   // job: engineer
   ```

2. **Object.getOwnPropertyNames()**

   Возвращает массив **всех** собственных свойств объекта, включая неперечисляемые (но не символы):
   ```javascript
   const obj = Object.create(null, {
     hidden: { value: 'secret', enumerable: false },
     visible: { value: 'public', enumerable: true },
   });

   console.log(Object.getOwnPropertyNames(obj)); // ['hidden', 'visible']
   ```

3. **Reflect.ownKeys()**

   Возвращает массив всех собственных ключей объекта, включая строковые и символьные:
   ```javascript
   const sym = Symbol('custom');
   const obj = {
     [sym]: 'symbol value',
     regularProp: 'regular value',
   };
   console.log(Reflect.ownKeys(obj)); // ['regularProp', Symbol(custom)]

   Reflect.ownKeys(obj).forEach((key) => {
     if (typeof key === 'symbol') {
       console.log(key.toString(), obj[key]);
     } else {
       console.log(key, obj[key]);
     }
   });
   ```

4. **for...in (с проверкой hasOwnProperty)**

   Перебирает все **перечисляемые** свойства объекта, включая унаследованные. Поэтому всегда проверяйте, что свойство принадлежит самому объекту:
   ```javascript
   function Person(name) {
     this.name = name;
   }
   Person.prototype.sayHello = function () {
     console.log(`Hello, I'm ${this.name}`);
   };

   const john = new Person('John');
   john.age = 30;

   // Без проверки — попадут и унаследованные свойства
   for (let prop in john) {
     console.log(prop); // name, age, sayHello
   }

   // С проверкой — только собственные свойства
   for (let prop in john) {
     if (john.hasOwnProperty(prop)) {
       console.log(prop); // name, age
     }
   }

   // Альтернатива — Object.keys()
   Object.keys(john).forEach((prop) => {
     console.log(prop); // name, age
   });
   ```

#### Особенности и рекомендации

- `Object.keys()`, `Object.values()`, `Object.entries()` перебирают только **собственные перечисляемые** свойства (не символы, не неперечисляемые).
- Для полного контроля используйте комбинацию `Object.getOwnPropertyNames()` и `Object.getOwnPropertySymbols()`.
- При использовании `for...in` всегда фильтруйте свойства с помощью `hasOwnProperty()`, чтобы избежать перебора унаследованных свойств.
- Для перебора только символов используйте `Object.getOwnPropertySymbols(obj)`.

**Samples:**
```javascript
const obj = { a: 1, b: 2 };
const sym = Symbol('c');
obj[sym] = 3;

console.log(Object.keys(obj)); // ['a', 'b']
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(c)]
console.log(Reflect.ownKeys(obj)); // ['a', 'b', Symbol(c)]
```

**Summary:**  
Вычисляемые свойства и современные методы перебора ключей делают работу с объектами в JavaScript гибкой, мощной и удобной. Используйте их для динамического построения структур данных, интеграции с внешними источниками и эффективной обработки коллекций.


### Arrays Built-in Methods

#### Copying and Modifying Arrays

Работа с массивами — одна из самых частых задач в JavaScript. Важно понимать разницу между методами, которые **создают новые массивы** (копирование), и теми, которые **изменяют исходный массив** (модификация).

#### Методы копирования массивов

Эти методы позволяют создавать новые массивы на основе существующих, не затрагивая оригинал. Это важно для иммутабельности данных, предотвращения неожиданных побочных эффектов и удобства работы с состоянием в современных фреймворках.

1. **slice()**
   - Возвращает новый массив, содержащий копию части или всего исходного массива.
   - Оригинальный массив не изменяется.
   ```javascript
   const original = [1, 2, 3, 4, 5];
   const fullCopy = original.slice();      // [1, 2, 3, 4, 5]
   const partialCopy = original.slice(1, 4); // [2, 3, 4]
   ```

2. **Spread оператор (`...`)**
   - Позволяет быстро создать копию массива или объединить несколько массивов.
   ```javascript
   const original = [1, 2, 3];
   const copy = [...original]; // [1, 2, 3]
   const combined = [...original, 4, 5, 6]; // [1, 2, 3, 4, 5, 6]
   ```

3. **Array.from()**
   - Создает новый массив из итерируемого или массивоподобного объекта.
   - Можно использовать для преобразования коллекций, NodeList и т.д.
   ```javascript
   const original = [1, 2, 3];
   const copy = Array.from(original); // [1, 2, 3]
   const sequence = Array.from({length: 5}, (_, i) => i + 1); // [1, 2, 3, 4, 5]
   ```

4. **concat()**
   - Объединяет два или более массивов, возвращая новый массив.
   ```javascript
   const arr1 = [1, 2, 3];
   const arr2 = [4, 5, 6];
   const combined = arr1.concat(arr2); // [1, 2, 3, 4, 5, 6]
   ```

5. **map()**
   - Создает новый массив, применяя функцию к каждому элементу исходного массива.
   - Оригинальный массив не изменяется.
   ```javascript
   const numbers = [1, 2, 3, 4, 5];
   const doubled = numbers.map(num => num * 2); // [2, 4, 6, 8, 10]
   ```

6. **filter()**
   - Создает новый массив, включающий только те элементы, которые удовлетворяют условию.
   ```javascript
   const numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
   const evens = numbers.filter(num => num % 2 === 0); // [2, 4, 6, 8, 10]
   ```

#### Методы модификации массивов

Эти методы **изменяют исходный массив**. Используйте их с осторожностью, особенно если важно сохранить оригинальные данные (например, в Redux или при работе с состоянием компонентов).

1. **push()**
   - Добавляет элементы в конец массива, возвращает новую длину.
   ```javascript
   const fruits = ['apple', 'banana'];
   fruits.push('orange'); // ['apple', 'banana', 'orange']
   ```

2. **pop()**
   - Удаляет последний элемент и возвращает его.
   ```javascript
   const fruits = ['apple', 'banana', 'orange'];
   const last = fruits.pop(); // last = 'orange', fruits = ['apple', 'banana']
   ```

3. **unshift()**
   - Добавляет элементы в начало массива, возвращает новую длину.
   ```javascript
   const fruits = ['banana', 'orange'];
   fruits.unshift('apple'); // ['apple', 'banana', 'orange']
   ```

4. **shift()**
   - Удаляет первый элемент и возвращает его.
   ```javascript
   const fruits = ['apple', 'banana', 'orange'];
   const first = fruits.shift(); // first = 'apple', fruits = ['banana', 'orange']
   ```

5. **splice()**
   - Универсальный метод для удаления, добавления и замены элементов.
   - Возвращает массив удалённых элементов.
   ```javascript
   const fruits = ['apple', 'banana', 'orange', 'mango'];
   const removed = fruits.splice(1, 2, 'kiwi', 'grape');
   // fruits = ['apple', 'kiwi', 'grape', 'mango'], removed = ['banana', 'orange']
   ```

6. **sort()**
   - Сортирует элементы массива на месте.
   - По умолчанию сортирует как строки, для чисел и объектов используйте функцию сравнения.
   ```javascript
   const numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5];
   numbers.sort((a, b) => a - b); // [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]
   ```

7. **reverse()**
   - Меняет порядок элементов на обратный.
   ```javascript
   const fruits = ['apple', 'banana', 'orange'];
   fruits.reverse(); // ['orange', 'banana', 'apple']
   ```

8. **forEach()**
   - Выполняет функцию для каждого элемента массива.
   - Не возвращает новый массив, используется для побочных эффектов.
   ```javascript
   const fruits = ['apple', 'banana', 'orange'];
   fruits.forEach((fruit, index) => {
     fruits[index] = fruit + ' hello';
   });
   // fruits = ['apple hello', 'banana hello', 'orange hello']
   ```

### Flattening Nested Arrays

Многомерные массивы (массивы внутри массивов) часто встречаются при работе с данными. Метод `flat()` позволяет "выпрямить" вложенные массивы до нужной глубины.

- **flat(depth)** — возвращает новый массив, в котором вложенные массивы раскрыты до указанной глубины.
- По умолчанию глубина равна 1.

```javascript
const nested = [1, [2, 3], [4, [5, 6]]];
console.log(nested.flat());    // [1, 2, 3, 4, [5, 6]]
console.log(nested.flat(2));  // [1, 2, 3, 4, 5, 6]
```

**Для старых версий JavaScript** используйте рекурсивную функцию:
```javascript
function flattenDeep(arr) {
  return arr.reduce(
    (acc, val) =>
      Array.isArray(val) ? acc.concat(flattenDeep(val)) : acc.concat(val),
    []
  );
}
console.log(flattenDeep(nested)); // [1, 2, 3, 4, 5, 6]
```